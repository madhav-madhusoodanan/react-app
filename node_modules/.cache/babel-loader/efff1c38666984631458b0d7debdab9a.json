{"ast":null,"code":"import { ethers } from \"ethers\";\nimport { toast } from \"react-toastify\";\nimport { fetchMetadata } from \"../data\";\n\nconst updatePlots = async (readContracts, currentPlots = [], DEBUG = false) => {\n  const newPlots = [];\n\n  if (readContracts) {\n    try {\n      const plotIds = await readContracts.CityDaoParcel.getPlotIds();\n      const plotPrices = await readContracts.CityDaoParcel.getAllPrices();\n      const statuses = await readContracts.CityDaoParcel.getAllSoldStatus();\n      const owners = await readContracts.CityDaoParcel.getOwners();\n      const ipfsHash = await readContracts.CityDaoParcel.getPlotsMetadataUri();\n      const jsonManifestBuffer = await fetchMetadata(ipfsHash);\n      const plotsMetadata = JSON.parse(jsonManifestBuffer.toString());\n\n      for (let index = 0; index < plotIds.length; index++) {\n        var _owners$index;\n\n        const plotId = plotIds[index];\n        const isSold = statuses[index];\n        const price = !isSold ? plotPrices[index] : undefined;\n        const owner = (_owners$index = owners[index]) !== null && _owners$index !== void 0 ? _owners$index : \"\";\n\n        try {\n          let metadata = {};\n\n          if (currentPlots.includes(plotIds[index])) {\n            var _currentPlots$index$m;\n\n            metadata = (_currentPlots$index$m = currentPlots[index].metadata) !== null && _currentPlots$index$m !== void 0 ? _currentPlots$index$m : {};\n          } else {\n            var _plotsMetadata$plots$, _plotsMetadata$plots$2, _plotsMetadata$plots$3, _plotsMetadata$plots$4, _plotsMetadata$plots$5, _plotsMetadata$plots$6, _plotsMetadata$plots$7;\n\n            // geojson uses lng, lat (rather than lat, lng)\n            const lng = (_plotsMetadata$plots$ = (_plotsMetadata$plots$2 = plotsMetadata.plots[index]) === null || _plotsMetadata$plots$2 === void 0 ? void 0 : (_plotsMetadata$plots$3 = _plotsMetadata$plots$2.geometry) === null || _plotsMetadata$plots$3 === void 0 ? void 0 : _plotsMetadata$plots$3.coordinates[0][0][0]) !== null && _plotsMetadata$plots$ !== void 0 ? _plotsMetadata$plots$ : null;\n            const lat = (_plotsMetadata$plots$4 = (_plotsMetadata$plots$5 = plotsMetadata.plots[index]) === null || _plotsMetadata$plots$5 === void 0 ? void 0 : (_plotsMetadata$plots$6 = _plotsMetadata$plots$5.geometry) === null || _plotsMetadata$plots$6 === void 0 ? void 0 : _plotsMetadata$plots$6.coordinates[0][0][1]) !== null && _plotsMetadata$plots$4 !== void 0 ? _plotsMetadata$plots$4 : null;\n            metadata = {\n              geojson: (_plotsMetadata$plots$7 = plotsMetadata.plots[index]) !== null && _plotsMetadata$plots$7 !== void 0 ? _plotsMetadata$plots$7 : {},\n              coordinates: lat && lng ? `${lat}${lat >= 0 ? \"°N\" : \"°S\"}, ${lng}${lng >= 0 ? \"°E\" : \"°W\"}` : undefined,\n              location: \"Clark, WY\"\n            };\n          }\n\n          newPlots.push({\n            id: plotId.toNumber(),\n            parcel: 0,\n            price: price ? ethers.utils.formatEther(price) : undefined,\n            sold: isSold,\n            owner: owner,\n            metadata: metadata\n          });\n        } catch (e) {\n          toast.error(\"Failed to read plot metadata. Please try again or contact CityDAO support.\", {\n            className: \"error\",\n            toastId: \"error-reading-metadata\"\n          });\n          DEBUG && console.log(e);\n        }\n      }\n    } catch (e) {\n      toast.error(`Failed to find CityDAO's contract. Make sure you're on the ${process.env.REACT_APP_NETWORK} network.`, {\n        className: \"error\",\n        toastId: \"contract-fail\"\n      });\n      DEBUG && console.log(e);\n    }\n  }\n\n  return newPlots;\n};\n\nexport default updatePlots;","map":{"version":3,"sources":["/home/madhav/Documents/freelancers/app/packages/react-app/src/helpers/UpdatePlots.ts"],"names":["ethers","toast","fetchMetadata","updatePlots","readContracts","currentPlots","DEBUG","newPlots","plotIds","CityDaoParcel","getPlotIds","plotPrices","getAllPrices","statuses","getAllSoldStatus","owners","getOwners","ipfsHash","getPlotsMetadataUri","jsonManifestBuffer","plotsMetadata","JSON","parse","toString","index","length","plotId","isSold","price","undefined","owner","metadata","includes","lng","plots","geometry","coordinates","lat","geojson","location","push","id","toNumber","parcel","utils","formatEther","sold","e","error","className","toastId","console","log","process","env","REACT_APP_NETWORK"],"mappings":"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","sourcesContent":["import { ethers } from \"ethers\";\nimport { toast } from \"react-toastify\";\nimport { fetchMetadata } from \"../data\";\nimport { Plot, PlotMetadata } from \"../models/Plot\";\nimport { GeojsonData } from \"../models/GeojsonData\";\n\nconst updatePlots = async (readContracts: any, currentPlots = [] as Plot[], DEBUG = false) => {\n  const newPlots: Plot[] = [];\n  if (readContracts) {\n    try {\n      const plotIds = await readContracts.CityDaoParcel.getPlotIds();\n      const plotPrices = await readContracts.CityDaoParcel.getAllPrices();\n      const statuses = await readContracts.CityDaoParcel.getAllSoldStatus();\n      const owners = await readContracts.CityDaoParcel.getOwners();\n      const ipfsHash = await readContracts.CityDaoParcel.getPlotsMetadataUri();\n      const jsonManifestBuffer = await fetchMetadata(ipfsHash);\n      const plotsMetadata = JSON.parse(jsonManifestBuffer.toString()) as GeojsonData;\n      for (let index = 0; index < plotIds.length; index++) {\n        const plotId = plotIds[index];\n        const isSold = statuses[index];\n        const price = !isSold ? plotPrices[index] : undefined;\n        const owner = owners[index] ?? \"\";\n        try {\n          let metadata: PlotMetadata = {};\n          if (currentPlots.includes(plotIds[index])) {\n            metadata = currentPlots[index].metadata ?? {};\n          } else {\n            // geojson uses lng, lat (rather than lat, lng)\n            const lng = plotsMetadata.plots[index]?.geometry?.coordinates[0][0][0] ?? null;\n            const lat = plotsMetadata.plots[index]?.geometry?.coordinates[0][0][1] ?? null;\n            metadata = {\n              geojson: plotsMetadata.plots[index] ?? {},\n              coordinates: lat && lng ? `${lat}${lat >= 0 ? \"°N\" : \"°S\"}, ${lng}${lng >= 0 ? \"°E\" : \"°W\"}` : undefined,\n              location: \"Clark, WY\",\n            };\n          }\n          newPlots.push({\n            id: plotId.toNumber(),\n            parcel: 0,\n            price: price ? ethers.utils.formatEther(price) : undefined,\n            sold: isSold,\n            owner: owner,\n            metadata: metadata,\n          });\n        } catch (e) {\n          toast.error(\"Failed to read plot metadata. Please try again or contact CityDAO support.\", {\n            className: \"error\",\n            toastId: \"error-reading-metadata\",\n          });\n          DEBUG && console.log(e);\n        }\n      }\n    } catch (e) {\n      toast.error(\n        `Failed to find CityDAO's contract. Make sure you're on the ${process.env.REACT_APP_NETWORK} network.`,\n        {\n          className: \"error\",\n          toastId: \"contract-fail\",\n        },\n      );\n      DEBUG && console.log(e);\n    }\n  }\n  return newPlots;\n};\n\nexport default updatePlots;\n"]},"metadata":{},"sourceType":"module"}