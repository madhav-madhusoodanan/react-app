{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar elliptic_1 = require(\"elliptic\");\n\nvar signature_1 = require(\"elliptic/lib/elliptic/ec/signature\");\n\nvar random_1 = require(\"../../random\");\n\nvar constants_1 = require(\"../../constants\");\n\nvar helpers_1 = require(\"../../helpers\");\n\nvar ec = new elliptic_1.ec('secp256k1');\n\nfunction ellipticCompress(publicKey) {\n  publicKey = helpers_1.sanitizePublicKey(publicKey);\n  var pubPoint = ec.keyFromPublic(publicKey);\n  var hex = pubPoint.getPublic().encode(constants_1.HEX_ENC, true);\n  return helpers_1.hexToBuffer(hex);\n}\n\nexports.ellipticCompress = ellipticCompress;\n\nfunction ellipticDecompress(publicKey) {\n  publicKey = helpers_1.sanitizePublicKey(publicKey);\n  var pubPoint = ec.keyFromPublic(publicKey);\n  var hex = pubPoint.getPublic().encode(constants_1.HEX_ENC, false);\n  return helpers_1.hexToBuffer(hex);\n}\n\nexports.ellipticDecompress = ellipticDecompress;\n\nfunction ellipticGeneratePrivate() {\n  var privateKey = random_1.randomBytes(constants_1.KEY_LENGTH);\n\n  while (!ellipticVerifyPrivateKey(privateKey)) {\n    privateKey = random_1.randomBytes(constants_1.KEY_LENGTH);\n  }\n\n  return privateKey;\n}\n\nexports.ellipticGeneratePrivate = ellipticGeneratePrivate;\n\nfunction ellipticVerifyPrivateKey(privateKey) {\n  return helpers_1.isValidPrivateKey(privateKey);\n}\n\nexports.ellipticVerifyPrivateKey = ellipticVerifyPrivateKey;\n\nfunction ellipticGetPublic(privateKey) {\n  var hex = ec.keyFromPrivate(privateKey).getPublic(false, constants_1.HEX_ENC);\n  return helpers_1.hexToBuffer(hex);\n}\n\nexports.ellipticGetPublic = ellipticGetPublic;\n\nfunction ellipticGetPublicCompressed(privateKey) {\n  var hex = ec.keyFromPrivate(privateKey).getPublic(true, constants_1.HEX_ENC);\n  return helpers_1.hexToBuffer(hex);\n}\n\nexports.ellipticGetPublicCompressed = ellipticGetPublicCompressed;\n\nfunction ellipticDerive(publicKeyB, privateKeyA) {\n  var keyA = ec.keyFromPrivate(privateKeyA);\n  var keyB = ec.keyFromPublic(publicKeyB);\n  var Px = keyA.derive(keyB.getPublic());\n  return Buffer.from(Px.toArray());\n}\n\nexports.ellipticDerive = ellipticDerive;\n\nfunction ellipticSignatureExport(sig) {\n  return signature_1.Signature({\n    r: sig.slice(0, 32),\n    s: sig.slice(32, 64),\n    recoveryParam: helpers_1.importRecoveryParam(sig.slice(64, 65))\n  }).toDER();\n}\n\nexports.ellipticSignatureExport = ellipticSignatureExport;\n\nfunction ellipticSign(msg, privateKey) {\n  var rsvSig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var signature = ec.sign(msg, privateKey, {\n    canonical: true\n  });\n  return rsvSig ? helpers_1.concatBuffers(helpers_1.hexToBuffer(helpers_1.sanitizeHex(signature.r.toString(16))), helpers_1.hexToBuffer(helpers_1.sanitizeHex(signature.s.toString(16))), helpers_1.exportRecoveryParam(signature.recoveryParam || 0)) : Buffer.from(signature.toDER());\n}\n\nexports.ellipticSign = ellipticSign;\n\nfunction ellipticRecover(sig, msg) {\n  var compressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (helpers_1.isValidDERSignature(sig)) {\n    throw new Error('Cannot recover from DER signatures');\n  }\n\n  var signature = helpers_1.splitSignature(sig);\n  var recoveryParam = helpers_1.importRecoveryParam(signature.v);\n  var hex = ec.recoverPubKey(msg, {\n    r: helpers_1.removeHexLeadingZeros(helpers_1.bufferToHex(signature.r)),\n    s: helpers_1.removeHexLeadingZeros(helpers_1.bufferToHex(signature.s)),\n    recoveryParam: recoveryParam\n  }, recoveryParam).encode(constants_1.HEX_ENC, compressed);\n  return helpers_1.hexToBuffer(hex);\n}\n\nexports.ellipticRecover = ellipticRecover;\n\nfunction ellipticVerify(sig, msg, publicKey) {\n  if (!helpers_1.isValidDERSignature) {\n    sig = ellipticSignatureExport(sig);\n  }\n\n  return ec.verify(msg, sig, publicKey);\n}\n\nexports.ellipticVerify = ellipticVerify;","map":null,"metadata":{},"sourceType":"script"}