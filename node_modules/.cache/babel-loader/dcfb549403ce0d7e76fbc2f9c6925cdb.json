{"ast":null,"code":"var _slicedToArray = require(\"/home/madhav/Documents/freelancers/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/home/madhav/Documents/freelancers/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/madhav/Documents/freelancers/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/home/madhav/Documents/freelancers/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/home/madhav/Documents/freelancers/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/madhav/Documents/freelancers/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Backoff = require('backoff');\n\nvar EventEmitter = require('events');\n\nvar inherits = require('util').inherits;\n\nvar WebSocket = global.WebSocket || require('ws');\n\nvar Subprovider = require('./subprovider');\n\nvar createPayload = require('../util/create-payload');\n\nvar WebsocketSubprovider = /*#__PURE__*/function (_Subprovider) {\n  \"use strict\";\n\n  _inherits(WebsocketSubprovider, _Subprovider);\n\n  var _super = _createSuper(WebsocketSubprovider);\n\n  function WebsocketSubprovider(_ref) {\n    var _this;\n\n    var rpcUrl = _ref.rpcUrl,\n        debug = _ref.debug,\n        origin = _ref.origin;\n\n    _classCallCheck(this, WebsocketSubprovider);\n\n    _this = _super.call(this); // inherit from EventEmitter\n\n    EventEmitter.call(_assertThisInitialized(_this));\n    Object.defineProperties(_assertThisInitialized(_this), {\n      _backoff: {\n        value: Backoff.exponential({\n          randomisationFactor: 0.2,\n          maxDelay: 5000\n        })\n      },\n      _connectTime: {\n        value: null,\n        writable: true\n      },\n      _log: {\n        value: debug ? function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return console.info.apply(console, ['[WSProvider]'].concat(args));\n        } : function () {}\n      },\n      _origin: {\n        value: origin\n      },\n      _pendingRequests: {\n        value: new Map()\n      },\n      _socket: {\n        value: null,\n        writable: true\n      },\n      _unhandledRequests: {\n        value: []\n      },\n      _url: {\n        value: rpcUrl\n      }\n    });\n    _this._handleSocketClose = _this._handleSocketClose.bind(_assertThisInitialized(_this));\n    _this._handleSocketMessage = _this._handleSocketMessage.bind(_assertThisInitialized(_this));\n    _this._handleSocketOpen = _this._handleSocketOpen.bind(_assertThisInitialized(_this)); // Called when a backoff timeout has finished. Time to try reconnecting.\n\n    _this._backoff.on('ready', function () {\n      _this._openSocket();\n    });\n\n    _this._openSocket();\n\n    return _this;\n  }\n\n  _createClass(WebsocketSubprovider, [{\n    key: \"handleRequest\",\n    value: function handleRequest(payload, next, end) {\n      if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n        this._unhandledRequests.push(Array.from(arguments));\n\n        this._log('Socket not open. Request queued.');\n\n        return;\n      }\n\n      this._pendingRequests.set(payload.id, [payload, end]);\n\n      var newPayload = createPayload(payload);\n      delete newPayload.origin;\n\n      this._socket.send(JSON.stringify(newPayload));\n\n      this._log(\"Sent: \".concat(newPayload.method, \" #\").concat(newPayload.id));\n    }\n  }, {\n    key: \"_handleSocketClose\",\n    value: function _handleSocketClose(_ref2) {\n      var reason = _ref2.reason,\n          code = _ref2.code;\n\n      this._log(\"Socket closed, code \".concat(code, \" (\").concat(reason || 'no reason', \")\")); // If the socket has been open for longer than 5 seconds, reset the backoff\n\n\n      if (this._connectTime && Date.now() - this._connectTime > 5000) {\n        this._backoff.reset();\n      }\n\n      this._socket.removeEventListener('close', this._handleSocketClose);\n\n      this._socket.removeEventListener('message', this._handleSocketMessage);\n\n      this._socket.removeEventListener('open', this._handleSocketOpen);\n\n      this._socket = null;\n\n      this._backoff.backoff();\n    }\n  }, {\n    key: \"_handleSocketMessage\",\n    value: function _handleSocketMessage(message) {\n      var payload;\n\n      try {\n        payload = JSON.parse(message.data);\n      } catch (e) {\n        this._log('Received a message that is not valid JSON:', payload);\n\n        return;\n      } // check if server-sent notification\n\n\n      if (payload.id === undefined) {\n        return this.engine.emit('data', null, payload);\n      } // ignore if missing\n\n\n      if (!this._pendingRequests.has(payload.id)) {\n        return;\n      } // retrieve payload + arguments\n\n\n      var _this$_pendingRequest = this._pendingRequests.get(payload.id),\n          _this$_pendingRequest2 = _slicedToArray(_this$_pendingRequest, 2),\n          originalReq = _this$_pendingRequest2[0],\n          end = _this$_pendingRequest2[1];\n\n      this._pendingRequests.delete(payload.id);\n\n      this._log(\"Received: \".concat(originalReq.method, \" #\").concat(payload.id)); // forward response\n\n\n      if (payload.error) {\n        return end(new Error(payload.error.message));\n      }\n\n      end(null, payload.result);\n    }\n  }, {\n    key: \"_handleSocketOpen\",\n    value: function _handleSocketOpen() {\n      var _this2 = this;\n\n      this._log('Socket open.');\n\n      this._connectTime = Date.now(); // Any pending requests need to be resent because our session was lost\n      // and will not get responses for them in our new session.\n\n      this._pendingRequests.forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            payload = _ref4[0],\n            end = _ref4[1];\n\n        _this2._unhandledRequests.push([payload, null, end]);\n      });\n\n      this._pendingRequests.clear();\n\n      var unhandledRequests = this._unhandledRequests.splice(0, this._unhandledRequests.length);\n\n      unhandledRequests.forEach(function (request) {\n        _this2.handleRequest.apply(_this2, request);\n      });\n    }\n  }, {\n    key: \"_openSocket\",\n    value: function _openSocket() {\n      this._log('Opening socket...');\n\n      this._socket = new WebSocket(this._url, [], this._origin ? {\n        headers: {\n          origin: this._origin\n        }\n      } : {});\n\n      this._socket.addEventListener('close', this._handleSocketClose);\n\n      this._socket.addEventListener('message', this._handleSocketMessage);\n\n      this._socket.addEventListener('open', this._handleSocketOpen);\n    }\n  }]);\n\n  return WebsocketSubprovider;\n}(Subprovider); // multiple inheritance\n\n\nObject.assign(WebsocketSubprovider.prototype, EventEmitter.prototype);\nmodule.exports = WebsocketSubprovider;","map":null,"metadata":{},"sourceType":"script"}