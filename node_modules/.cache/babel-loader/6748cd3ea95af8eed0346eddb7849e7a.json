{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar is_typedarray_1 = __importDefault(require(\"is-typedarray\"));\n\nvar typedarray_to_buffer_1 = __importDefault(require(\"typedarray-to-buffer\"));\n\nvar ENC_HEX = 'hex';\nvar ENC_UTF8 = 'utf8';\nvar TYPE_BUFFER = 'buffer';\nvar TYPE_ARRAY = 'array';\nvar TYPE_TYPED_ARRAY = 'typed-array';\nvar TYPE_ARRAY_BUFFER = 'array-buffer';\nvar STRING_ZERO = '0';\n\nfunction bufferToArray(buf) {\n  return new Uint8Array(buf);\n}\n\nexports.bufferToArray = bufferToArray;\n\nfunction bufferToHex(buf) {\n  var prefixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var hex = buf.toString(ENC_HEX);\n  return prefixed ? addHexPrefix(hex) : hex;\n}\n\nexports.bufferToHex = bufferToHex;\n\nfunction bufferToUtf8(buf) {\n  return buf.toString(ENC_UTF8);\n}\n\nexports.bufferToUtf8 = bufferToUtf8;\n\nfunction bufferToNumber(buf) {\n  return hexToNumber(bufferToHex(buf));\n}\n\nexports.bufferToNumber = bufferToNumber;\n\nfunction arrayToBuffer(arr) {\n  return typedarray_to_buffer_1.default(arr);\n}\n\nexports.arrayToBuffer = arrayToBuffer;\n\nfunction arrayToHex(arr) {\n  var prefixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return bufferToHex(arrayToBuffer(arr), prefixed);\n}\n\nexports.arrayToHex = arrayToHex;\n\nfunction arrayToUtf8(arr) {\n  return bufferToUtf8(arrayToBuffer(arr));\n}\n\nexports.arrayToUtf8 = arrayToUtf8;\n\nfunction arrayToNumber(arr) {\n  return bufferToNumber(arrayToBuffer(arr));\n}\n\nexports.arrayToNumber = arrayToNumber;\n\nfunction hexToBuffer(hex) {\n  return Buffer.from(removeHexPrefix(hex), ENC_HEX);\n}\n\nexports.hexToBuffer = hexToBuffer;\n\nfunction hexToArray(hex) {\n  return bufferToArray(hexToBuffer(hex));\n}\n\nexports.hexToArray = hexToArray;\n\nfunction hexToUtf8(hex) {\n  return bufferToUtf8(hexToBuffer(hex));\n}\n\nexports.hexToUtf8 = hexToUtf8;\n\nfunction hexToNumber(hex) {\n  return new bn_js_1.default(removeHexPrefix(hex), 'hex').toNumber();\n}\n\nexports.hexToNumber = hexToNumber;\n\nfunction utf8ToBuffer(utf8) {\n  return Buffer.from(utf8, ENC_UTF8);\n}\n\nexports.utf8ToBuffer = utf8ToBuffer;\n\nfunction utf8ToArray(utf8) {\n  return bufferToArray(utf8ToBuffer(utf8));\n}\n\nexports.utf8ToArray = utf8ToArray;\n\nfunction utf8ToHex(utf8) {\n  var prefixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return bufferToHex(utf8ToBuffer(utf8), prefixed);\n}\n\nexports.utf8ToHex = utf8ToHex;\n\nfunction utf8ToNumber(utf8) {\n  return new bn_js_1.default(utf8, 10).toNumber();\n}\n\nexports.utf8ToNumber = utf8ToNumber;\n\nfunction numberToBuffer(num) {\n  var hex = numberToHex(num);\n  return hexToBuffer(hex);\n}\n\nexports.numberToBuffer = numberToBuffer;\n\nfunction numberToArray(num) {\n  var hex = numberToHex(num);\n  return hexToArray(hex);\n}\n\nexports.numberToArray = numberToArray;\n\nfunction numberToHex(num, prefixed) {\n  var hex = removeHexPrefix(sanitizeHex(new bn_js_1.default(num).toString(16)));\n  return prefixed ? addHexPrefix(hex) : hex;\n}\n\nexports.numberToHex = numberToHex;\n\nfunction numberToUtf8(num) {\n  var utf8 = new bn_js_1.default(num).toString();\n  return utf8;\n}\n\nexports.numberToUtf8 = numberToUtf8;\n\nfunction isHexString(value, length) {\n  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n\n  if (length && value.length !== 2 + 2 * length) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.isHexString = isHexString;\n\nfunction isBuffer(val) {\n  return Buffer.isBuffer(val);\n}\n\nexports.isBuffer = isBuffer;\n\nfunction isTypedArray(val) {\n  return is_typedarray_1.default.strict(val) && !isBuffer(val);\n}\n\nexports.isTypedArray = isTypedArray;\n\nfunction isArrayBuffer(val) {\n  return !isTypedArray(val) && !isBuffer(val) && typeof val.byteLength !== 'undefined';\n}\n\nexports.isArrayBuffer = isArrayBuffer;\n\nfunction getType(val) {\n  if (isBuffer(val)) {\n    return TYPE_BUFFER;\n  } else if (isTypedArray(val)) {\n    return TYPE_TYPED_ARRAY;\n  } else if (isArrayBuffer(val)) {\n    return TYPE_ARRAY_BUFFER;\n  } else if (Array.isArray(val)) {\n    return TYPE_ARRAY;\n  } else {\n    return typeof val;\n  }\n}\n\nexports.getType = getType;\n\nfunction getEncoding(str) {\n  if (isHexString(str)) {\n    return ENC_HEX;\n  }\n\n  return ENC_UTF8;\n}\n\nexports.getEncoding = getEncoding;\n\nfunction concatBuffers() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var result = Buffer.concat(args);\n  return result;\n}\n\nexports.concatBuffers = concatBuffers;\n\nfunction trimLeft(data, length) {\n  var diff = data.length - length;\n\n  if (diff > 0) {\n    data = data.slice(diff);\n  }\n\n  return data;\n}\n\nexports.trimLeft = trimLeft;\n\nfunction trimRight(data, length) {\n  return data.slice(0, length);\n}\n\nexports.trimRight = trimRight;\n\nfunction padString(str, length, left) {\n  var padding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : STRING_ZERO;\n  var diff = length - str.length;\n  var result = str;\n\n  if (diff > 0) {\n    var pad = padding.repeat(diff);\n    result = left ? pad + str : str + pad;\n  }\n\n  return result;\n}\n\nfunction padLeft(str, length) {\n  var padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : STRING_ZERO;\n  return padString(str, length, true, padding);\n}\n\nexports.padLeft = padLeft;\n\nfunction padRight(str, length) {\n  var padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : STRING_ZERO;\n  return padString(str, length, false, padding);\n}\n\nexports.padRight = padRight;\n\nfunction removeHexPrefix(hex) {\n  return hex.replace(/^0x/, '');\n}\n\nexports.removeHexPrefix = removeHexPrefix;\n\nfunction addHexPrefix(hex) {\n  return hex.startsWith('0x') ? hex : \"0x\".concat(hex);\n}\n\nexports.addHexPrefix = addHexPrefix;\n\nfunction sanitizeHex(hex) {\n  hex = removeHexPrefix(hex);\n  hex = hex.length % 2 !== 0 ? STRING_ZERO + hex : hex;\n\n  if (hex) {\n    hex = addHexPrefix(hex);\n  }\n\n  return hex;\n}\n\nexports.sanitizeHex = sanitizeHex;\n\nfunction removeHexLeadingZeros(hex) {\n  var prefixed = hex.startsWith('0x');\n  hex = removeHexPrefix(hex);\n  hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;\n  return prefixed ? addHexPrefix(hex) : hex;\n}\n\nexports.removeHexLeadingZeros = removeHexLeadingZeros;","map":null,"metadata":{},"sourceType":"script"}