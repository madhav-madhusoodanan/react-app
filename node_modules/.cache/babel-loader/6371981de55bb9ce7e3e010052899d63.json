{"ast":null,"code":"var ethers = require('ethers');\n\nvar fs = require('fs');\n\nvar ProviderEngine = require('web3-provider-engine'); //const CacheSubprovider = require('web3-provider-engine/subproviders/cache.js')\n\n\nvar FixtureSubprovider = require('web3-provider-engine/subproviders/fixture.js');\n\nvar FilterSubprovider = require('web3-provider-engine/subproviders/filters.js');\n\nvar HookedWalletSubprovider = require('web3-provider-engine/subproviders/hooked-wallet-ethtx.js'); // const VmSubprovider = require('web3-provider-engine/subproviders/vm.js')\n\n\nvar NonceSubprovider = require('web3-provider-engine/subproviders/nonce-tracker.js');\n\nvar RpcSubprovider = require('web3-provider-engine/subproviders/rpc.js');\n\nvar WebSocketSubProvider = require('web3-provider-engine/subproviders/websocket.js');\n\nvar sigUtil = require('eth-sig-util');\n\nmodule.exports = BurnerProvider;\nvar metaAccount;\n\nfunction BurnerProvider() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var engine; // = new ProviderEngine()\n\n  console.log(\"ðŸš›ðŸš›ðŸš›ðŸš›ðŸš›ðŸš›ðŸš› BurnerProvider ðŸš›ðŸš›ðŸš›ðŸš›ðŸš›ðŸš›ðŸš›\"); // let them pass in a simple string for the options and use that as infura or whatevs\n\n  if (typeof opts == \"string\") {\n    var rpcUrl = opts;\n    opts = {\n      rpcUrl: rpcUrl\n    };\n  }\n\n  if (opts && opts.provider) {\n    //console.log(\"Adding optional provider: \",opts.provider)\n    //engine.addProvider(opts.provider)\n    engine = opts.provider; //console.log(\"Adding optional provider: \",opts.provider)\n  } else {\n    /*engine.addProvider(opts.provider)*/\n    engine = new ProviderEngine();\n  }\n\n  var provider = new ethers.providers.Web3Provider(engine);\n  var privateKeyStorageString = \"metaPrivateKey\";\n\n  if (opts.namespace) {\n    privateKeyStorageString = privateKeyStorageString + \"_\" + opts.namespace;\n  }\n\n  if (opts && opts.privateKey) {\n    //if they passed in a private key, use it to generate an account\n    //metaAccount = provider.eth.accounts.privateKeyToAccount(opts.privateKey)\n    metaAccount = new ethers.Wallet(opts.privateKey, provider); //console.log(\"metaAccount from pk\",metaAccount)\n  } else if (typeof localStorage != \"undefined\" && typeof localStorage.setItem == \"function\") {\n    //load private key out of local storage\n    var metaPrivateKey = localStorage.getItem(privateKeyStorageString);\n    if (metaPrivateKey == \"0\") metaPrivateKey = false;\n    if (metaPrivateKey && metaPrivateKey.length !== 66) metaPrivateKey = false; //if(metaPrivateKey) metaAccount = provider.eth.accounts.privateKeyToAccount(metaPrivateKey)\n\n    if (metaPrivateKey) metaAccount = new ethers.Wallet(metaPrivateKey, provider);\n  } else {\n    //local storage isn't an option and they didn't pass in a pk attempted to use the filesystem\n    try {\n      var fsPk = fs.readFileSync(\".pk\").toString();\n\n      if (fsPk) {\n        metaAccount = new ethers.Wallet(fsPk, provider);\n      }\n    } catch (e) {} // if not just generate a temp account in memory for this session\n    // (just leave metaAccount false and it will be created in the next block)\n\n  }\n\n  if (!metaAccount) {\n    //generate account either from a provided mnemonic, pk, or random generation\n    if (opts.mnemonic) {\n      var bip39 = require('bip39');\n\n      var hdkey = require('ethereumjs-wallet/hdkey');\n\n      var index = \"0\";\n\n      if (typeof opts.index != \"undefined\") {\n        index = opts.index;\n      }\n\n      var seed = bip39.mnemonicToSeedSync(opts.mnemonic);\n      var hdwallet = hdkey.fromMasterSeed(seed);\n      var wallet_hdpath = \"m/44'/60'/0'/0/\";\n      var wallet = hdwallet.derivePath(wallet_hdpath + index).getWallet();\n      var privateKey = \"0x\" + wallet.getPrivateKey().toString(\"hex\"); //metaAccount = provider.eth.accounts.privateKeyToAccount(privateKey)\n\n      metaAccount = new ethers.Wallet(privateKey, provider);\n    } else {\n      //metaAccount = provider.eth.accounts.create();\n      metaAccount = ethers.Wallet.createRandom();\n    } //if we needed to generate, save the pk to local storage\n\n\n    if (typeof localStorage != \"undefined\" && typeof localStorage.setItem == \"function\") {\n      localStorage.setItem(privateKeyStorageString, metaAccount.privateKey);\n    } else {\n      //if we can't use local storage try saving it to the filesystem\n      try {\n        fs.writeFileSync(\".pk\", metaAccount.privateKey);\n      } catch (e) {}\n    }\n  }\n\n  opts.getPrivateKey = function (address, cb) {\n    if (address.toLowerCase() == metaAccount.address.toLowerCase()) {\n      cb(null, Buffer.from(metaAccount.privateKey.replace(\"0x\", \"\"), 'hex'));\n    } else {\n      cb(\"unknown account\");\n    }\n  };\n\n  opts.getAccounts = function (cb) {\n    //console.log(\"metaAccount\",metaAccount)\n    cb(false, [metaAccount.address]);\n  }; // static results\n\n\n  engine.addProvider(new FixtureSubprovider({\n    web3_clientVersion: 'ProviderEngine/v0.0.0/javascript',\n    net_listening: true,\n    eth_hashrate: '0x00',\n    eth_mining: false,\n    eth_syncing: true\n  })); // cache layer // PULLED THANKS TO A HEADS UP FROM GSN! SORRY GUYS!\n  //engine.addProvider(new CacheSubprovider())\n  // filters\n\n  engine.addProvider(new FilterSubprovider()); // pending nonce\n\n  engine.addProvider(new NonceSubprovider()); // vm\n  // engine.addProvider(new VmSubprovider())\n  // id mgmt\n\n  var hookedWalletSubprovider = new HookedWalletSubprovider(opts);\n\n  hookedWalletSubprovider.signTypedMessage = function (msgParams, cb) {\n    opts.getPrivateKey(msgParams.from, function (err, privateKey) {\n      if (err) return cb(err);\n\n      if (typeof msgParams.data === 'string') {\n        msgParams.data = JSON.parse(msgParams.data);\n      }\n\n      var serialized = sigUtil.signTypedData_v4(privateKey, msgParams);\n      cb(null, serialized);\n    });\n  };\n\n  engine.addProvider(hookedWalletSubprovider);\n\n  if (opts && opts.rpcUrl && opts.rpcUrl.indexOf && opts.rpcUrl.indexOf(\"wss://\") == 0) {\n    engine.addProvider(new WebSocketSubProvider(opts));\n  } else {\n    // data source\n    engine.addProvider(new RpcSubprovider(opts));\n  } // start polling for blocks\n\n\n  engine.start(); //do this to prevent skipCache: true -- to prevent PollingBlockTracker undefined errors from eth-block-tracker/src/polling.js\n  //engine._blockTracker._setSkipCacheFlag = false\n\n  return engine;\n}","map":null,"metadata":{},"sourceType":"script"}