{"ast":null,"code":"import _regeneratorRuntime from \"/home/madhav/Documents/freelancers/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/home/madhav/Documents/freelancers/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _objectWithoutProperties from \"/home/madhav/Documents/freelancers/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _asyncToGenerator from \"/home/madhav/Documents/freelancers/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"/home/madhav/Documents/freelancers/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"/home/madhav/Documents/freelancers/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport SturdyWebSocket from 'sturdy-websocket';\nimport CryptoEs from 'crypto-es';\nvar networks = {\n  bitcoin: {\n    '1': 'main',\n    '2': 'testnet'\n  },\n  ethereum: {\n    '1': 'main',\n    '3': 'ropsten',\n    '4': 'rinkeby',\n    '5': 'goerli',\n    '42': 'kovan',\n    '100': 'xdai'\n  }\n};\nvar DEFAULT_RATE_LIMIT_RULES = {\n  points: 150,\n  duration: 1\n};\nvar QUEUE_LIMIT = 10000;\n\nfunction createEmitter() {\n  return {\n    listeners: {},\n    on: function on(eventCode, listener) {\n      // check if valid eventCode\n      switch (eventCode) {\n        case 'txSent':\n        case 'txPool':\n        case 'txConfirmed':\n        case 'txSpeedUp':\n        case 'txCancel':\n        case 'txFailed':\n        case 'all':\n          break;\n\n        default:\n          throw new Error(\"\".concat(eventCode, \" is not a valid event code, for a list of valid event codes see: https://github.com/blocknative/sdk\"));\n      } // check that listener is a function\n\n\n      if (typeof listener !== 'function') {\n        throw new Error('Listener must be a function');\n      } // add listener for the eventCode\n\n\n      this.listeners[eventCode] = listener;\n    },\n    emit: function emit(state) {\n      if (this.listeners[state.eventCode]) {\n        return this.listeners[state.eventCode](state);\n      }\n\n      if (this.listeners.all) {\n        return this.listeners.all(state);\n      }\n    }\n  };\n}\n\nfunction networkName(blockchain, id) {\n  return networks[blockchain][id];\n}\n\nfunction serverEcho(eventCode) {\n  switch (eventCode) {\n    case 'txRequest':\n    case 'nsfFail':\n    case 'txRepeat':\n    case 'txAwaitingApproval':\n    case 'txConfirmReminder':\n    case 'txSendFail':\n    case 'txError':\n    case 'txUnderPriced':\n    case 'txSent':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction last(arr) {\n  return arr.reverse()[0];\n} // isAddress and isTxid are not meant to perform real validation,\n// just needs to work out if it is an address or a transaction id\n// the server will do more thorough validation\n\n\nfunction isAddress(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 42;\n\n    case 'bitcoin':\n      return addressOrHash.length !== 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction isTxid(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 66;\n\n    case 'bitcoin':\n      return addressOrHash.length === 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction wait(time) {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, time);\n  });\n}\n\nfunction transaction(hash, id) {\n  var _transaction;\n\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // create startTime for transaction\n\n  var startTime = Date.now(); // create emitter for transaction\n\n  var emitter = createEmitter(); // create eventCode for transaction\n\n  var eventCode = 'txSent'; // put in queue\n\n  this._watchedTransactions.push({\n    hash: hash,\n    emitter: emitter\n  });\n\n  var transaction = (_transaction = {}, _defineProperty(_transaction, this._system === 'ethereum' ? 'hash' : 'txid', hash), _defineProperty(_transaction, \"id\", id || hash), _defineProperty(_transaction, \"startTime\", startTime), _defineProperty(_transaction, \"status\", 'sent'), _transaction);\n\n  var newState = _objectSpread(_objectSpread({}, transaction), {}, {\n    eventCode: eventCode\n  }); // logEvent to server\n\n\n  this._sendMessage({\n    eventCode: eventCode,\n    categoryCode: 'activeTransaction',\n    transaction: transaction\n  });\n\n  var transactionObj = {\n    details: transaction,\n    emitter: emitter\n  };\n\n  function emitState() {\n    var emitterResult = emitter.emit(newState);\n\n    this._transactionHandlers.forEach(function (handler) {\n      return handler({\n        transaction: newState,\n        emitterResult: emitterResult\n      });\n    });\n  } // emit after delay to allow for listener to be registered\n\n\n  setTimeout(emitState.bind(this), 5);\n  return transactionObj;\n}\n\nfunction account(address) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // lowercase the address if Ethereum\n\n  address = this._system === 'ethereum' ? address.toLowerCase() : address; // create emitter for transaction\n\n  var emitter = createEmitter(); // create eventCode for transaction\n\n  var eventCode = 'watch';\n\n  var existingAddressWatcher = this._watchedAccounts.find(function (ac) {\n    return ac.address === address;\n  });\n\n  if (existingAddressWatcher) {\n    // add to existing emitters array\n    existingAddressWatcher.emitters.push(emitter);\n  } else {\n    // put in accounts queue\n    this._watchedAccounts.push({\n      address: address,\n      emitters: [emitter]\n    });\n  } // logEvent to server\n\n\n  this._sendMessage({\n    eventCode: eventCode,\n    categoryCode: 'accountAddress',\n    account: {\n      address: address\n    }\n  });\n\n  return {\n    emitter: emitter,\n    details: {\n      address: address\n    }\n  };\n}\n\nfunction event(eventObj) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n\n  this._sendMessage(eventObj);\n}\n\nfunction unsubscribe(addressOrHash) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  var address = isAddress(this._system, addressOrHash);\n  var txid = isTxid(this._system, addressOrHash); // check if it is an address or a hash\n\n  if (address) {\n    var normalizedAddress = this._system === 'ethereum' ? addressOrHash.toLowerCase() : addressOrHash; // remove address from accounts\n\n    this._watchedAccounts = this._watchedAccounts.filter(function (ac) {\n      return ac.address !== normalizedAddress;\n    }); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'accountAddress',\n      eventCode: 'unwatch',\n      account: {\n        address: normalizedAddress\n      }\n    });\n  } else if (txid) {\n    var _transaction2;\n\n    // remove transaction from transactions\n    this._watchedTransactions = this._watchedTransactions.filter(function (tx) {\n      return tx.hash !== addressOrHash;\n    }); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'activeTransaction',\n      eventCode: 'unwatch',\n      transaction: (_transaction2 = {}, _defineProperty(_transaction2, this._system === 'ethereum' ? 'hash' : 'txid', addressOrHash), _defineProperty(_transaction2, \"id\", addressOrHash), _defineProperty(_transaction2, \"status\", 'unsubscribed'), _transaction2)\n    });\n  } else {\n    throw new Error(\"Error trying to unsubscribe \".concat(addressOrHash, \": not a valid address or transaction id/hash\"));\n  }\n}\n\nvar version = \"2.1.5\";\n\nfunction sendMessage(msg) {\n  if (this._queuedMessages.length > QUEUE_LIMIT) {\n    throw new Error(\"Queue limit of \".concat(QUEUE_LIMIT, \" messages has been reached.\"));\n  }\n\n  this._queuedMessages.push(createEventLog.bind(this)(msg));\n\n  if (!this._processingQueue) {\n    this._processQueue();\n  }\n}\n\nfunction processQueue() {\n  return _processQueue.apply(this, arguments);\n}\n\nfunction _processQueue() {\n  _processQueue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var msg, delay;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            this._processingQueue = true;\n\n            if (this._connected) {\n              _context.next = 4;\n              break;\n            }\n\n            _context.next = 4;\n            return waitForConnectionOpen.bind(this)();\n\n          case 4:\n            if (!(this._queuedMessages.length > 0)) {\n              _context.next = 18;\n              break;\n            }\n\n            _context.next = 7;\n            return wait(1);\n\n          case 7:\n            if (!(this._waitToRetry !== null)) {\n              _context.next = 11;\n              break;\n            }\n\n            _context.next = 10;\n            return this._waitToRetry;\n\n          case 10:\n            this._waitToRetry = null;\n\n          case 11:\n            msg = this._queuedMessages.shift();\n            delay = this._limitRules.duration / this._limitRules.points * 1000;\n            _context.next = 15;\n            return wait(delay);\n\n          case 15:\n            this._socket.send(msg);\n\n            _context.next = 4;\n            break;\n\n          case 18:\n            this._processingQueue = false;\n            this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n\n          case 20:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n  return _processQueue.apply(this, arguments);\n}\n\nfunction handleMessage(msg) {\n  var _JSON$parse = JSON.parse(msg.data),\n      status = _JSON$parse.status,\n      reason = _JSON$parse.reason,\n      event = _JSON$parse.event,\n      connectionId = _JSON$parse.connectionId,\n      retryMs = _JSON$parse.retryMs,\n      limitRules = _JSON$parse.limitRules,\n      blockedMsg = _JSON$parse.blockedMsg;\n\n  if (connectionId) {\n    if (typeof window !== 'undefined') {\n      window.localStorage.setItem(this._storageKey, connectionId);\n    }\n\n    this._connectionId = connectionId;\n  } // handle any errors from the server\n\n\n  if (status === 'error') {\n    if (reason.includes('ratelimit')) {\n      this._waitToRetry = wait(retryMs);\n      this._limitRules = limitRules; // add blocked msg to the front of the queue\n\n      blockedMsg && this._queuedMessages.unshift(blockedMsg);\n      return;\n    }\n\n    if (reason.includes('not a valid API key')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('network not supported')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('maximum allowed amount')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin txid error\n\n\n    if (reason.includes('invalid txid')) {\n      var _reason = \"\".concat(event.transaction.txid, \" is an invalid txid\");\n\n      if (this._onerror) {\n        this._onerror({\n          message: _reason,\n          transaction: event.transaction.txid\n        });\n\n        return;\n      } else {\n        throw new Error(_reason);\n      }\n    } // handle ethereum transaction hash error\n\n\n    if (reason.includes('invalid hash')) {\n      var _reason2 = \"\".concat(event.transaction.hash, \" is an invalid transaction hash\");\n\n      if (this._onerror) {\n        this._onerror({\n          message: _reason2,\n          transaction: event.transaction.hash\n        });\n\n        return;\n      } else {\n        throw new Error(_reason2);\n      }\n    } // handle general address error\n\n\n    if (reason.includes('invalid address')) {\n      var _reason3 = \"\".concat(event.account.address, \" is an invalid address\");\n\n      if (this._onerror) {\n        this._onerror({\n          message: _reason3,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(_reason3);\n      }\n    } // handle bitcoin specific address error\n\n\n    if (reason.includes('not a valid Bitcoin')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum specific address error\n\n\n    if (reason.includes('not a valid Ethereum')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // throw error that comes back from the server without formatting the message\n\n\n    if (this._onerror) {\n      this._onerror({\n        message: reason\n      });\n\n      return;\n    } else {\n      throw new Error(reason);\n    }\n  }\n\n  if (event && event.transaction) {\n    var _transaction3 = event.transaction,\n        eventCode = event.eventCode,\n        contractCall = event.contractCall; // flatten in to one object\n\n    var newState = this._system === 'ethereum' ? _objectSpread(_objectSpread({}, _transaction3), {}, {\n      eventCode: eventCode,\n      contractCall: contractCall\n    }) : _objectSpread(_objectSpread({}, _transaction3), {}, {\n      eventCode: eventCode\n    }); // ignore server echo and unsubscribe messages\n\n    if (serverEcho(eventCode) || _transaction3.status === 'unsubscribed') {\n      return;\n    } // handle change of hash in speedup and cancel events\n\n\n    if (eventCode === 'txSpeedUp' || eventCode === 'txCancel') {\n      this._watchedTransactions = this._watchedTransactions.map(function (tx) {\n        if (tx.hash === _transaction3.originalHash) {\n          // reassign hash parameter in transaction queue to new hash or txid\n          tx.hash = _transaction3.hash || _transaction3.txid;\n        }\n\n        return tx;\n      });\n    }\n\n    var watchedAddress = _transaction3.watchedAddress && this._system === 'ethereum' ? _transaction3.watchedAddress.toLowerCase() : _transaction3.watchedAddress;\n\n    if (watchedAddress) {\n      var accountObj = this._watchedAccounts.find(function (ac) {\n        return ac.address === watchedAddress;\n      });\n\n      var emitterResult = accountObj ? last(accountObj.emitters.map(function (emitter) {\n        return emitter.emit(newState);\n      })) : false;\n\n      this._transactionHandlers.forEach(function (handler) {\n        return handler({\n          transaction: newState,\n          emitterResult: emitterResult\n        });\n      });\n    } else {\n      var transactionObj = this._watchedTransactions.find(function (tx) {\n        return tx.hash === _transaction3.hash || _transaction3.txid;\n      });\n\n      var _emitterResult = transactionObj && transactionObj.emitter.emit(newState);\n\n      this._transactionHandlers.forEach(function (handler) {\n        return handler({\n          transaction: newState,\n          emitterResult: _emitterResult\n        });\n      });\n    }\n  }\n}\n\nfunction createEventLog(msg) {\n  return JSON.stringify(_objectSpread({\n    timeStamp: new Date(),\n    dappId: this._dappId,\n    version: version,\n    blockchain: {\n      system: this._system,\n      network: networkName(this._system, this._networkId) || 'local'\n    }\n  }, msg));\n}\n\nfunction waitForConnectionOpen() {\n  var _this = this;\n\n  return new Promise(function (resolve) {\n    var interval = setInterval(function () {\n      if (_this._connected) {\n        setTimeout(resolve, 100);\n        clearInterval(interval);\n      }\n    });\n  });\n}\n\nfunction validateType(options) {\n  var name = options.name,\n      value = options.value,\n      type = options.type,\n      optional = options.optional,\n      customValidation = options.customValidation;\n\n  if (!optional && typeof value === 'undefined') {\n    throw new Error(\"\\\"\".concat(name, \"\\\" is required\"));\n  }\n\n  if (typeof value !== 'undefined' && (type === 'array' ? Array.isArray(type) : typeof value !== type)) {\n    throw new Error(\"\\\"\".concat(name, \"\\\" must be of type: \").concat(type, \", received type: \").concat(typeof value, \" from value: \").concat(value));\n  }\n\n  if (typeof value !== 'undefined' && customValidation && !customValidation(value)) {\n    throw new Error(\"\\\"\".concat(value, \"\\\" is not a valid \\\"\").concat(name, \"\\\"\"));\n  }\n}\n\nfunction validateOptions(options) {\n  validateType({\n    name: 'sdk options',\n    value: options,\n    type: 'object'\n  });\n\n  var dappId = options.dappId,\n      system = options.system,\n      name = options.name,\n      networkId = options.networkId,\n      transactionHandlers = options.transactionHandlers,\n      apiUrl = options.apiUrl,\n      ws = options.ws,\n      onopen = options.onopen,\n      ondown = options.ondown,\n      onreopen = options.onreopen,\n      onerror = options.onerror,\n      onclose = options.onclose,\n      otherParams = _objectWithoutProperties(options, [\"dappId\", \"system\", \"name\", \"networkId\", \"transactionHandlers\", \"apiUrl\", \"ws\", \"onopen\", \"ondown\", \"onreopen\", \"onerror\", \"onclose\"]);\n\n  invalidParams(otherParams, ['dappId', 'system', 'name', 'networkId', 'transactionHandlers', 'apiUrl', 'ws', 'onopen', 'ondown', 'onreopen', 'onerror', 'onclose'], 'Initialization Options');\n  validateType({\n    name: 'dappId',\n    value: dappId,\n    type: 'string'\n  });\n  validateType({\n    name: 'system',\n    value: system,\n    type: 'string',\n    optional: true,\n    customValidation: validSystem\n  });\n  validateType({\n    name: 'name',\n    value: name,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'networkId',\n    value: networkId,\n    type: 'number'\n  });\n  validateType({\n    name: 'transactionHandler',\n    value: transactionHandlers,\n    type: 'array',\n    optional: true\n  });\n\n  if (transactionHandlers) {\n    transactionHandlers.forEach(function (handler) {\n      return validateType({\n        name: 'transactionHandler',\n        value: handler,\n        type: 'function'\n      });\n    });\n  }\n\n  validateType({\n    name: 'apiUrl',\n    value: apiUrl,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'ws',\n    value: ws,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onopen',\n    value: onopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'ondown',\n    value: ondown,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onreopen',\n    value: onreopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onerror',\n    value: onerror,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onclose',\n    value: onclose,\n    type: 'function',\n    optional: true\n  });\n}\n\nfunction validSystem(system) {\n  return !!networks[system];\n}\n\nfunction invalidParams(params, validParams, functionName) {\n  var invalid = Object.keys(params);\n\n  if (invalid.length > 0) {\n    throw new Error(\"\".concat(invalid[0], \" is not a valid parameter for \").concat(functionName, \", must be one of the following valid parameters: \").concat(validParams.join(', ')));\n  }\n}\n\nvar DEFAULT_NAME = 'unknown';\nvar DEFAULT_SYSTEM = 'ethereum';\n\nvar Blocknative = function Blocknative(options) {\n  var _this2 = this;\n\n  _classCallCheck(this, Blocknative);\n\n  validateOptions(options);\n  var dappId = options.dappId,\n      _options$system = options.system,\n      system = _options$system === void 0 ? DEFAULT_SYSTEM : _options$system,\n      _options$name = options.name,\n      name = _options$name === void 0 ? DEFAULT_NAME : _options$name,\n      networkId = options.networkId,\n      _options$transactionH = options.transactionHandlers,\n      transactionHandlers = _options$transactionH === void 0 ? [] : _options$transactionH,\n      apiUrl = options.apiUrl,\n      ws = options.ws,\n      onopen = options.onopen,\n      ondown = options.ondown,\n      onreopen = options.onreopen,\n      onerror = options.onerror,\n      onclose = options.onclose;\n  var socket = new SturdyWebSocket(apiUrl || 'wss://api.blocknative.com/v0', ws ? {\n    wsConstructor: ws\n  } : {});\n  socket.onopen = onOpen.bind(this, onopen);\n  socket.ondown = onDown.bind(this, ondown);\n  socket.onreopen = onReopen.bind(this, onreopen);\n  socket.onmessage = handleMessage.bind(this);\n\n  socket.onerror = function (error) {\n    return onerror && onerror({\n      message: 'There was a WebSocket error',\n      error: error\n    });\n  };\n\n  socket.onclose = function () {\n    _this2._pingTimeout && clearInterval(_this2._pingTimeout);\n    onclose && onclose();\n  };\n\n  var storageKey = CryptoEs.SHA1(\"\".concat(dappId, \" - \").concat(name)).toString();\n  var storedConnectionId = typeof window !== 'undefined' && window.localStorage.getItem(storageKey);\n  this._storageKey = storageKey;\n  this._connectionId = storedConnectionId || undefined;\n  this._dappId = dappId;\n  this._system = system;\n  this._networkId = networkId;\n  this._transactionHandlers = transactionHandlers;\n  this._socket = socket;\n  this._connected = false;\n  this._sendMessage = sendMessage.bind(this);\n  this._watchedTransactions = [];\n  this._watchedAccounts = [];\n  this._pingTimeout = undefined;\n  this._destroyed = false;\n  this._onerror = onerror;\n  this._queuedMessages = [];\n  this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n  this._waitToRetry = null;\n  this._processingQueue = false;\n  this._processQueue = processQueue.bind(this);\n\n  if (this._socket.ws.on) {\n    this._heartbeat = function () {\n      _this2._pingTimeout && clearTimeout(_this2._pingTimeout);\n      _this2._pingTimeout = setTimeout(function () {\n        // terminate connection if we haven't heard the server ping after server timeout plus conservative latency delay\n        // Sturdy Websocket will handle the new connection logic\n        _this2._socket.ws.terminate();\n      }, 30000 + 1000);\n    };\n\n    this._socket.ws.on('ping', function () {\n      _this2._heartbeat && _this2._heartbeat();\n    });\n  } // public API\n\n\n  this.transaction = transaction.bind(this);\n  this.account = account.bind(this);\n  this.event = event.bind(this);\n  this.unsubscribe = unsubscribe.bind(this);\n\n  this.destroy = function () {\n    _this2._socket.close();\n\n    _this2._destroyed = true; // call onclose manually here as SturdyWebSocket doesn't currently work as expected\n    // https://github.com/dphilipson/sturdy-websocket/issues/5\n\n    _this2._socket.onclose();\n  };\n};\n\nfunction onOpen(handler) {\n  this._connected = true;\n  var msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  }; // send this message directly rather than put in queue\n\n  this._socket.send(createEventLog.bind(this)(msg));\n\n  this._heartbeat && this._heartbeat();\n  handler && handler();\n}\n\nfunction onDown(handler, closeEvent) {\n  this._connected = false;\n\n  if (handler) {\n    handler(closeEvent);\n  }\n\n  this._pingTimeout && clearTimeout(this._pingTimeout);\n}\n\nfunction onReopen(handler) {\n  var _this3 = this;\n\n  this._connected = true;\n  var msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  };\n\n  this._socket.send(createEventLog.bind(this)(msg)); // re-register all accounts to be watched by server upon\n  // re-connection as they don't get transferred over automatically\n  // to the new connection like tx hashes do\n\n\n  this._watchedAccounts.forEach(function (account) {\n    _this3._sendMessage({\n      eventCode: 'accountAddress',\n      categoryCode: 'watch',\n      account: {\n        address: account.address\n      }\n    });\n  });\n\n  if (handler) {\n    handler();\n  }\n\n  if (this._socket.ws.on) {\n    // need to re-register ping event since new connection\n    this._socket.ws.on('ping', function () {\n      _this3._heartbeat && _this3._heartbeat();\n    });\n\n    this._heartbeat();\n  }\n}\n\nexport default Blocknative;","map":null,"metadata":{},"sourceType":"module"}