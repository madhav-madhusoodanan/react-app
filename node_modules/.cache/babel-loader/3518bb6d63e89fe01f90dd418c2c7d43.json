{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar env_1 = require(\"./lib/env\");\n\nvar secp256k1_1 = require(\"./lib/secp256k1\");\n\nvar elliptic_1 = require(\"./lib/elliptic\");\n\nvar constants_1 = require(\"./constants\");\n\nvar helpers_1 = require(\"./helpers\");\n\nfunction generatePrivate() {\n  return env_1.isNode() ? secp256k1_1.secp256k1GeneratePrivate() : elliptic_1.ellipticGeneratePrivate();\n}\n\nexports.generatePrivate = generatePrivate;\n\nfunction checkPrivateKey(privateKey) {\n  helpers_1.assert(privateKey.length === constants_1.KEY_LENGTH, constants_1.ERROR_BAD_PRIVATE_KEY);\n  helpers_1.assert(helpers_1.isValidPrivateKey(privateKey), constants_1.ERROR_BAD_PRIVATE_KEY);\n}\n\nexports.checkPrivateKey = checkPrivateKey;\n\nfunction checkPublicKey(publicKey) {\n  helpers_1.assert(publicKey.length === constants_1.PREFIXED_DECOMPRESSED_LENGTH || publicKey.length === constants_1.PREFIXED_KEY_LENGTH, constants_1.ERROR_BAD_PUBLIC_KEY);\n\n  if (publicKey.length === constants_1.PREFIXED_DECOMPRESSED_LENGTH) {\n    helpers_1.assert(publicKey[0] === 4, constants_1.ERROR_BAD_PUBLIC_KEY);\n  }\n\n  if (publicKey.length === constants_1.PREFIXED_KEY_LENGTH) {\n    helpers_1.assert(publicKey[0] === 2 || publicKey[0] === 3, constants_1.ERROR_BAD_PUBLIC_KEY);\n  }\n}\n\nexports.checkPublicKey = checkPublicKey;\n\nfunction checkMessage(msg) {\n  helpers_1.assert(msg.length > 0, constants_1.ERROR_EMPTY_MESSAGE);\n  helpers_1.assert(msg.length <= constants_1.MAX_MSG_LENGTH, constants_1.ERROR_MESSAGE_TOO_LONG);\n}\n\nexports.checkMessage = checkMessage;\n\nfunction compress(publicKey) {\n  if (helpers_1.isCompressed(publicKey)) {\n    return publicKey;\n  }\n\n  return env_1.isNode() ? secp256k1_1.secp256k1Compress(publicKey) : elliptic_1.ellipticCompress(publicKey);\n}\n\nexports.compress = compress;\n\nfunction decompress(publicKey) {\n  if (helpers_1.isDecompressed(publicKey)) {\n    return publicKey;\n  }\n\n  return env_1.isNode() ? secp256k1_1.secp256k1Decompress(publicKey) : elliptic_1.ellipticDecompress(publicKey);\n}\n\nexports.decompress = decompress;\n\nfunction getPublic(privateKey) {\n  checkPrivateKey(privateKey);\n  return env_1.isNode() ? secp256k1_1.secp256k1GetPublic(privateKey) : elliptic_1.ellipticGetPublic(privateKey);\n}\n\nexports.getPublic = getPublic;\n\nfunction getPublicCompressed(privateKey) {\n  checkPrivateKey(privateKey);\n  return env_1.isNode() ? secp256k1_1.secp256k1GetPublicCompressed(privateKey) : elliptic_1.ellipticGetPublicCompressed(privateKey);\n}\n\nexports.getPublicCompressed = getPublicCompressed;\n\nfunction generateKeyPair() {\n  var privateKey = generatePrivate();\n  var publicKey = getPublic(privateKey);\n  return {\n    privateKey: privateKey,\n    publicKey: publicKey\n  };\n}\n\nexports.generateKeyPair = generateKeyPair;\n\nfunction signatureExport(sig) {\n  return env_1.isNode() ? secp256k1_1.secp256k1SignatureExport(sig) : elliptic_1.ellipticSignatureExport(sig);\n}\n\nexports.signatureExport = signatureExport;\n\nfunction sign(privateKey, msg) {\n  var rsvSig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  checkPrivateKey(privateKey);\n  checkMessage(msg);\n  return env_1.isNode() ? secp256k1_1.secp256k1Sign(msg, privateKey, rsvSig) : elliptic_1.ellipticSign(msg, privateKey, rsvSig);\n}\n\nexports.sign = sign;\n\nfunction recover(msg, sig) {\n  var compressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  checkMessage(msg);\n  return env_1.isNode() ? secp256k1_1.secp256k1Recover(sig, msg, compressed) : elliptic_1.ellipticRecover(sig, msg, compressed);\n}\n\nexports.recover = recover;\n\nfunction verify(publicKey, msg, sig) {\n  checkPublicKey(publicKey);\n  checkMessage(msg);\n  var sigGood = env_1.isNode() ? secp256k1_1.secp256k1Verify(sig, msg, publicKey) : elliptic_1.ellipticVerify(sig, msg, publicKey);\n\n  if (sigGood) {\n    return null;\n  } else {\n    throw new Error('Bad signature');\n  }\n}\n\nexports.verify = verify;","map":null,"metadata":{},"sourceType":"script"}