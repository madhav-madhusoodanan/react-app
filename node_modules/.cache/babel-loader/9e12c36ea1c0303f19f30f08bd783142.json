{"ast":null,"code":"\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _secp256k1 = __importStar(require(\"secp256k1\"));\n\nvar random_1 = require(\"../../random\");\n\nvar constants_1 = require(\"../../constants\");\n\nvar helpers_1 = require(\"../../helpers\");\n\nexports.secp256k1 = _secp256k1;\n\nfunction secp256k1Compress(publicKey) {\n  publicKey = helpers_1.sanitizePublicKey(publicKey);\n  return exports.secp256k1.publicKeyConvert(publicKey, true);\n}\n\nexports.secp256k1Compress = secp256k1Compress;\n\nfunction secp256k1Decompress(publicKey) {\n  publicKey = helpers_1.sanitizePublicKey(publicKey);\n  return exports.secp256k1.publicKeyConvert(publicKey, false);\n}\n\nexports.secp256k1Decompress = secp256k1Decompress;\n\nfunction secp256k1GeneratePrivate() {\n  var privateKey = random_1.randomBytes(constants_1.KEY_LENGTH);\n\n  while (!secp256k1VerifyPrivateKey(privateKey)) {\n    privateKey = random_1.randomBytes(constants_1.KEY_LENGTH);\n  }\n\n  return privateKey;\n}\n\nexports.secp256k1GeneratePrivate = secp256k1GeneratePrivate;\n\nfunction secp256k1VerifyPrivateKey(privateKey) {\n  return exports.secp256k1.privateKeyVerify(privateKey);\n}\n\nexports.secp256k1VerifyPrivateKey = secp256k1VerifyPrivateKey;\n\nfunction secp256k1GetPublic(privateKey) {\n  var result = exports.secp256k1.publicKeyCreate(privateKey, false);\n  return result;\n}\n\nexports.secp256k1GetPublic = secp256k1GetPublic;\n\nfunction secp256k1GetPublicCompressed(privateKey) {\n  var result = exports.secp256k1.publicKeyCreate(privateKey, true);\n  return result;\n}\n\nexports.secp256k1GetPublicCompressed = secp256k1GetPublicCompressed;\n\nfunction secp256k1SignatureExport(sig) {\n  return exports.secp256k1.signatureExport(sig);\n}\n\nexports.secp256k1SignatureExport = secp256k1SignatureExport;\n\nfunction secp256k1SignatureImport(sig) {\n  return exports.secp256k1.signatureImport(sig);\n}\n\nexports.secp256k1SignatureImport = secp256k1SignatureImport;\n\nfunction secp256k1Sign(msg, privateKey) {\n  var rsvSig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var _exports$secp256k1$si = exports.secp256k1.sign(msg, privateKey),\n      signature = _exports$secp256k1$si.signature,\n      recovery = _exports$secp256k1$si.recovery;\n\n  return rsvSig ? helpers_1.concatBuffers(signature, helpers_1.exportRecoveryParam(recovery)) : secp256k1SignatureExport(signature);\n}\n\nexports.secp256k1Sign = secp256k1Sign;\n\nfunction secp256k1Recover(sig, msg) {\n  var compressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (helpers_1.isValidDERSignature(sig)) {\n    throw new Error('Cannot recover from DER signatures');\n  }\n\n  var _helpers_1$sanitizeRS = helpers_1.sanitizeRSVSignature(sig),\n      signature = _helpers_1$sanitizeRS.signature,\n      recovery = _helpers_1$sanitizeRS.recovery;\n\n  return exports.secp256k1.recover(msg, signature, recovery, compressed);\n}\n\nexports.secp256k1Recover = secp256k1Recover;\n\nfunction secp256k1Verify(sig, msg, publicKey) {\n  if (helpers_1.isValidDERSignature(sig)) {\n    sig = secp256k1SignatureImport(sig);\n  }\n\n  sig = helpers_1.sanitizeRSVSignature(sig).signature;\n  return exports.secp256k1.verify(msg, sig, publicKey);\n}\n\nexports.secp256k1Verify = secp256k1Verify;\n\nfunction secp256k1Derive(publicKey, privateKey, compressed) {\n  var result = exports.secp256k1.ecdhUnsafe(publicKey, privateKey, compressed);\n  return helpers_1.trimLeft(result, constants_1.KEY_LENGTH);\n}\n\nexports.secp256k1Derive = secp256k1Derive;","map":null,"metadata":{},"sourceType":"script"}