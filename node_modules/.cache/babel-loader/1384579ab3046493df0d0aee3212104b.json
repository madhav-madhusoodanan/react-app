{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/madhav/Documents/freelancers/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar aes_1 = require(\"./aes\");\n\nvar ecdh_1 = require(\"./ecdh\");\n\nvar ecdsa_1 = require(\"./ecdsa\");\n\nvar hmac_1 = require(\"./hmac\");\n\nvar random_1 = require(\"./random\");\n\nvar sha2_1 = require(\"./sha2\");\n\nvar constants_1 = require(\"./constants\");\n\nvar helpers_1 = require(\"./helpers\");\n\nfunction getSharedKey(privateKey, publicKey) {\n  publicKey = ecdsa_1.decompress(publicKey);\n  return ecdh_1.derive(privateKey, publicKey);\n}\n\nfunction getEncryptionKey(hash) {\n  return Buffer.from(hash.slice(constants_1.LENGTH_0, constants_1.KEY_LENGTH));\n}\n\nfunction getMacKey(hash) {\n  return Buffer.from(hash.slice(constants_1.KEY_LENGTH));\n}\n\nfunction getEciesKeys(privateKey, publicKey) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var sharedKey, hash;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            sharedKey = getSharedKey(privateKey, publicKey);\n            _context.next = 3;\n            return sha2_1.sha512(sharedKey);\n\n          case 3:\n            hash = _context.sent;\n            return _context.abrupt(\"return\", {\n              encryptionKey: getEncryptionKey(hash),\n              macKey: getMacKey(hash)\n            });\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n\nfunction getEciesKeysSync(privateKey, publicKey) {\n  var sharedKey = getSharedKey(privateKey, publicKey);\n  var hash = sha2_1.sha512Sync(sharedKey);\n  return {\n    encryptionKey: getEncryptionKey(hash),\n    macKey: getMacKey(hash)\n  };\n}\n\nfunction getEphemKeyPair(opts) {\n  var _a, _b;\n\n  var ephemPrivateKey = ((_a = opts) === null || _a === void 0 ? void 0 : _a.ephemPrivateKey) || random_1.randomBytes(constants_1.KEY_LENGTH);\n\n  while (!helpers_1.isValidPrivateKey(ephemPrivateKey)) {\n    ephemPrivateKey = ((_b = opts) === null || _b === void 0 ? void 0 : _b.ephemPrivateKey) || random_1.randomBytes(constants_1.KEY_LENGTH);\n  }\n\n  var ephemPublicKey = ecdsa_1.getPublic(ephemPrivateKey);\n  return {\n    ephemPrivateKey: ephemPrivateKey,\n    ephemPublicKey: ephemPublicKey\n  };\n}\n\nfunction encrypt(publicKeyTo, msg, opts) {\n  var _a;\n\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var _getEphemKeyPair, ephemPrivateKey, ephemPublicKey, _yield$getEciesKeys, encryptionKey, macKey, iv, ciphertext, dataToMac, mac;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _getEphemKeyPair = getEphemKeyPair(opts), ephemPrivateKey = _getEphemKeyPair.ephemPrivateKey, ephemPublicKey = _getEphemKeyPair.ephemPublicKey;\n            _context2.next = 3;\n            return getEciesKeys(ephemPrivateKey, publicKeyTo);\n\n          case 3:\n            _yield$getEciesKeys = _context2.sent;\n            encryptionKey = _yield$getEciesKeys.encryptionKey;\n            macKey = _yield$getEciesKeys.macKey;\n            iv = ((_a = opts) === null || _a === void 0 ? void 0 : _a.iv) || random_1.randomBytes(constants_1.IV_LENGTH);\n            _context2.next = 9;\n            return aes_1.aesCbcEncrypt(iv, encryptionKey, msg);\n\n          case 9:\n            ciphertext = _context2.sent;\n            dataToMac = helpers_1.concatBuffers(iv, ephemPublicKey, ciphertext);\n            _context2.next = 13;\n            return hmac_1.hmacSha256Sign(macKey, dataToMac);\n\n          case 13:\n            mac = _context2.sent;\n            return _context2.abrupt(\"return\", {\n              iv: iv,\n              ephemPublicKey: ephemPublicKey,\n              ciphertext: ciphertext,\n              mac: mac\n            });\n\n          case 15:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n}\n\nexports.encrypt = encrypt;\n\nfunction decrypt(privateKey, opts) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    var ephemPublicKey, iv, mac, ciphertext, _yield$getEciesKeys2, encryptionKey, macKey, dataToMac, macTest, msg;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            ephemPublicKey = opts.ephemPublicKey, iv = opts.iv, mac = opts.mac, ciphertext = opts.ciphertext;\n            _context3.next = 3;\n            return getEciesKeys(privateKey, ephemPublicKey);\n\n          case 3:\n            _yield$getEciesKeys2 = _context3.sent;\n            encryptionKey = _yield$getEciesKeys2.encryptionKey;\n            macKey = _yield$getEciesKeys2.macKey;\n            dataToMac = helpers_1.concatBuffers(iv, ephemPublicKey, ciphertext);\n            _context3.next = 9;\n            return hmac_1.hmacSha256Verify(macKey, dataToMac, mac);\n\n          case 9:\n            macTest = _context3.sent;\n            helpers_1.assert(macTest, constants_1.ERROR_BAD_MAC);\n            _context3.next = 13;\n            return aes_1.aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);\n\n          case 13:\n            msg = _context3.sent;\n            return _context3.abrupt(\"return\", msg);\n\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n}\n\nexports.decrypt = decrypt;\n\nfunction encryptSync(publicKeyTo, msg, opts) {\n  var _a;\n\n  var _getEphemKeyPair2 = getEphemKeyPair(opts),\n      ephemPrivateKey = _getEphemKeyPair2.ephemPrivateKey,\n      ephemPublicKey = _getEphemKeyPair2.ephemPublicKey;\n\n  var _getEciesKeysSync = getEciesKeysSync(ephemPrivateKey, publicKeyTo),\n      encryptionKey = _getEciesKeysSync.encryptionKey,\n      macKey = _getEciesKeysSync.macKey;\n\n  var iv = ((_a = opts) === null || _a === void 0 ? void 0 : _a.iv) || random_1.randomBytes(constants_1.IV_LENGTH);\n  var ciphertext = aes_1.aesCbcEncryptSync(iv, encryptionKey, msg);\n  var dataToMac = helpers_1.concatBuffers(iv, ephemPublicKey, ciphertext);\n  var mac = hmac_1.hmacSha256SignSync(macKey, dataToMac);\n  return {\n    iv: iv,\n    ephemPublicKey: ephemPublicKey,\n    ciphertext: ciphertext,\n    mac: mac\n  };\n}\n\nexports.encryptSync = encryptSync;\n\nfunction decryptSync(privateKey, opts) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n    var ephemPublicKey, iv, mac, ciphertext, _getEciesKeysSync2, encryptionKey, macKey, dataToMac, macTest, msg;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            ephemPublicKey = opts.ephemPublicKey, iv = opts.iv, mac = opts.mac, ciphertext = opts.ciphertext;\n            _getEciesKeysSync2 = getEciesKeysSync(privateKey, ephemPublicKey), encryptionKey = _getEciesKeysSync2.encryptionKey, macKey = _getEciesKeysSync2.macKey;\n            dataToMac = helpers_1.concatBuffers(iv, ephemPublicKey, ciphertext);\n            macTest = hmac_1.hmacSha256VerifySync(macKey, dataToMac, mac);\n            helpers_1.assert(macTest, constants_1.ERROR_BAD_MAC);\n            msg = aes_1.aesCbcDecryptSync(opts.iv, encryptionKey, opts.ciphertext);\n            return _context4.abrupt(\"return\", msg);\n\n          case 7:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n}\n\nexports.decryptSync = decryptSync;\n\nfunction serialize(opts) {\n  var ephemPublicKey = ecdsa_1.compress(opts.ephemPublicKey);\n  return helpers_1.concatBuffers(opts.iv, ephemPublicKey, opts.mac, opts.ciphertext);\n}\n\nexports.serialize = serialize;\n\nfunction deserialize(buf) {\n  var slice0 = constants_1.LENGTH_0;\n  var slice1 = slice0 + constants_1.IV_LENGTH;\n  var slice2 = slice1 + constants_1.PREFIXED_KEY_LENGTH;\n  var slice3 = slice2 + constants_1.MAC_LENGTH;\n  var slice4 = buf.length;\n  return {\n    iv: buf.slice(slice0, slice1),\n    ephemPublicKey: ecdsa_1.decompress(buf.slice(slice1, slice2)),\n    mac: buf.slice(slice2, slice3),\n    ciphertext: buf.slice(slice3, slice4)\n  };\n}\n\nexports.deserialize = deserialize;","map":null,"metadata":{},"sourceType":"script"}