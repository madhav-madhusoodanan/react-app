{"ast":null,"code":"\"use strict\"; // Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\n\nvar _slicedToArray = require(\"/home/madhav/Documents/freelancers/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/home/madhav/Documents/freelancers/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/madhav/Documents/freelancers/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/madhav/Documents/freelancers/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/madhav/Documents/freelancers/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletSDKRelay = void 0;\n\nvar bind_decorator_1 = __importDefault(require(\"bind-decorator\"));\n\nvar eth_rpc_errors_1 = require(\"eth-rpc-errors\");\n\nvar rxjs_1 = require(\"rxjs\");\n\nvar operators_1 = require(\"rxjs/operators\");\n\nvar EventListener_1 = require(\"../connection/EventListener\");\n\nvar WalletSDKConnection_1 = require(\"../connection/WalletSDKConnection\");\n\nvar util_1 = require(\"../util\");\n\nvar aes256gcm = __importStar(require(\"./aes256gcm\"));\n\nvar Session_1 = require(\"./Session\");\n\nvar WalletSDKRelayAbstract_1 = require(\"./WalletSDKRelayAbstract\");\n\nvar Web3Method_1 = require(\"./Web3Method\");\n\nvar Web3RequestCanceledMessage_1 = require(\"./Web3RequestCanceledMessage\");\n\nvar Web3RequestMessage_1 = require(\"./Web3RequestMessage\");\n\nvar Web3Response_1 = require(\"./Web3Response\");\n\nvar Web3ResponseMessage_1 = require(\"./Web3ResponseMessage\");\n\nvar WalletSDKRelay = /*#__PURE__*/function (_WalletSDKRelayAbstra) {\n  _inherits(WalletSDKRelay, _WalletSDKRelayAbstra);\n\n  var _super = _createSuper(WalletSDKRelay);\n\n  function WalletSDKRelay(options) {\n    var _this;\n\n    _classCallCheck(this, WalletSDKRelay);\n\n    _this = _super.call(this);\n    _this.accountsCallback = null;\n    _this.chainCallback = null;\n    _this.appName = \"\";\n    _this.appLogoUrl = null;\n    _this.subscriptions = new rxjs_1.Subscription();\n    _this.linkAPIUrl = options.linkAPIUrl;\n    _this.storage = options.storage;\n    _this._session = Session_1.Session.load(options.storage) || new Session_1.Session(options.storage).save();\n    _this.relayEventManager = options.relayEventManager;\n    _this.eventListener = options.eventListener;\n    _this.connection = new WalletSDKConnection_1.WalletSDKConnection(_this._session.id, _this._session.key, _this.linkAPIUrl, _this.eventListener);\n\n    _this.subscriptions.add(_this.connection.incomingEvent$.pipe((0, operators_1.filter)(function (m) {\n      return m.event === \"Web3Response\";\n    })).subscribe({\n      next: _this.handleIncomingEvent\n    }) // eslint-disable-line @typescript-eslint/unbound-method\n    );\n\n    _this.subscriptions.add(_this.connection.linked$.pipe((0, operators_1.skip)(1), (0, operators_1.tap)(function (linked) {\n      var _a;\n\n      _this.isLinked = linked;\n\n      var cachedAddresses = _this.storage.getItem(WalletSDKRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);\n\n      if (linked) {\n        // Only set linked session variable one way\n        _this.session.linked = linked;\n      }\n\n      _this.isUnlinkedErrorState = false;\n\n      if (cachedAddresses) {\n        var addresses = cachedAddresses.split(\" \");\n        var wasConnectedViaStandalone = _this.storage.getItem(\"IsStandaloneSigning\") === \"true\";\n\n        if (addresses[0] !== \"\" && !linked && _this.session.linked && !wasConnectedViaStandalone) {\n          _this.isUnlinkedErrorState = true;\n\n          var sessionIdHash = _this.getSessionIdHash();\n\n          (_a = _this.eventListener) === null || _a === void 0 ? void 0 : _a.onEvent(EventListener_1.EVENTS.UNLINKED_ERROR_STATE, {\n            sessionIdHash: sessionIdHash,\n            origin: location.origin\n          });\n        }\n      }\n    })).subscribe()); // if session is marked destroyed, reset and reload\n\n\n    _this.subscriptions.add(_this.connection.sessionConfig$.pipe((0, operators_1.filter)(function (c) {\n      return !!c.metadata && c.metadata.__destroyed === \"1\";\n    })).subscribe(function () {\n      var _a;\n\n      var alreadyDestroyed = _this.connection.isDestroyed;\n      (_a = _this.eventListener) === null || _a === void 0 ? void 0 : _a.onEvent(EventListener_1.EVENTS.METADATA_DESTROYED, {\n        alreadyDestroyed: alreadyDestroyed,\n        sessionIdHash: _this.getSessionIdHash(),\n        origin: location.origin\n      });\n      return _this.resetAndReload();\n    }));\n\n    _this.subscriptions.add(_this.connection.sessionConfig$.pipe((0, operators_1.filter)(function (c) {\n      return c.metadata && c.metadata.WalletUsername !== undefined;\n    })).pipe((0, operators_1.mergeMap)(function (c) {\n      return aes256gcm.decrypt(c.metadata.WalletUsername, _this._session.secret);\n    })).subscribe({\n      next: function next(walletUsername) {\n        _this.storage.setItem(WalletSDKRelayAbstract_1.WALLET_USER_NAME_KEY, walletUsername);\n      },\n      error: function error() {\n        var _a;\n\n        (_a = _this.eventListener) === null || _a === void 0 ? void 0 : _a.onEvent(EventListener_1.EVENTS.GENERAL_ERROR, {\n          message: \"Had error decrypting\",\n          value: \"username\"\n        });\n      }\n    }));\n\n    _this.subscriptions.add(_this.connection.sessionConfig$.pipe((0, operators_1.filter)(function (c) {\n      return c.metadata && c.metadata.AppVersion !== undefined;\n    })).pipe((0, operators_1.mergeMap)(function (c) {\n      return aes256gcm.decrypt(c.metadata.AppVersion, _this._session.secret);\n    })).subscribe({\n      next: function next(appVersion) {\n        _this.storage.setItem(WalletSDKRelayAbstract_1.APP_VERSION_KEY, appVersion);\n      },\n      error: function error() {\n        var _a;\n\n        (_a = _this.eventListener) === null || _a === void 0 ? void 0 : _a.onEvent(EventListener_1.EVENTS.GENERAL_ERROR, {\n          message: \"Had error decrypting\",\n          value: \"appversion\"\n        });\n      }\n    }));\n\n    _this.subscriptions.add(_this.connection.sessionConfig$.pipe((0, operators_1.filter)(function (c) {\n      return c.metadata && c.metadata.ChainId !== undefined && c.metadata.JsonRpcUrl !== undefined;\n    })).pipe((0, operators_1.mergeMap)(function (c) {\n      return (0, rxjs_1.zip)(aes256gcm.decrypt(c.metadata.ChainId, _this._session.secret), aes256gcm.decrypt(c.metadata.JsonRpcUrl, _this._session.secret));\n    })).pipe((0, operators_1.distinctUntilChanged)()).subscribe({\n      next: function next(_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            chainId = _ref2[0],\n            jsonRpcUrl = _ref2[1];\n\n        if (_this.chainCallback) {\n          _this.chainCallback(chainId, jsonRpcUrl);\n        }\n      },\n      error: function error() {\n        var _a;\n\n        (_a = _this.eventListener) === null || _a === void 0 ? void 0 : _a.onEvent(EventListener_1.EVENTS.GENERAL_ERROR, {\n          message: \"Had error decrypting\",\n          value: \"chainId|jsonRpcUrl\"\n        });\n      }\n    }));\n\n    _this.subscriptions.add(_this.connection.sessionConfig$.pipe((0, operators_1.filter)(function (c) {\n      return c.metadata && c.metadata.EthereumAddress !== undefined;\n    })).pipe((0, operators_1.mergeMap)(function (c) {\n      return aes256gcm.decrypt(c.metadata.EthereumAddress, _this._session.secret);\n    })).subscribe({\n      next: function next(selectedAddress) {\n        if (_this.accountsCallback) {\n          _this.accountsCallback([selectedAddress]);\n        }\n\n        if (WalletSDKRelay.accountRequestCallbackIds.size > 0) {\n          // We get the ethereum address from the metadata.  If for whatever\n          // reason we don't get a response via an explicit web3 message\n          // we can still fulfill the eip1102 request.\n          Array.from(WalletSDKRelay.accountRequestCallbackIds.values()).forEach(function (id) {\n            var message = (0, Web3ResponseMessage_1.Web3ResponseMessage)({\n              id: id,\n              response: (0, Web3Response_1.RequestEthereumAccountsResponse)([selectedAddress])\n            });\n\n            _this.invokeCallback(Object.assign(Object.assign({}, message), {\n              id: id\n            }));\n          });\n          WalletSDKRelay.accountRequestCallbackIds.clear();\n        }\n      },\n      error: function error() {\n        var _a;\n\n        (_a = _this.eventListener) === null || _a === void 0 ? void 0 : _a.onEvent(EventListener_1.EVENTS.GENERAL_ERROR, {\n          message: \"Had error decrypting\",\n          value: \"selectedAddress\"\n        });\n      }\n    }));\n\n    _this.ui = options.uiConstructor({\n      linkAPIUrl: options.linkAPIUrl,\n      version: options.version,\n      darkMode: options.darkMode,\n      session: _this._session,\n      connected$: _this.connection.connected$\n    });\n\n    _this.connection.connect();\n\n    return _this;\n  }\n\n  _createClass(WalletSDKRelay, [{\n    key: \"attachUI\",\n    value: function attachUI() {\n      this.ui.attach();\n    }\n  }, {\n    key: \"resetAndReload\",\n    value: function resetAndReload() {\n      var _this2 = this;\n\n      this.connection.setSessionMetadata(\"__destroyed\", \"1\").pipe((0, operators_1.timeout)(1000), (0, operators_1.catchError)(function (_) {\n        return (0, rxjs_1.of)(null);\n      })).subscribe(function (_) {\n        var _a, _b, _c;\n\n        try {\n          _this2.subscriptions.unsubscribe();\n        } catch (err) {\n          (_a = _this2.eventListener) === null || _a === void 0 ? void 0 : _a.onEvent(EventListener_1.EVENTS.GENERAL_ERROR, {\n            message: \"Had error unsubscribing\"\n          });\n        }\n\n        (_b = _this2.eventListener) === null || _b === void 0 ? void 0 : _b.onEvent(EventListener_1.EVENTS.SESSION_STATE_CHANGE, {\n          method: \"relay::resetAndReload\",\n          sessionMetadataChange: \"__destroyed, 1\",\n          sessionIdHash: _this2.getSessionIdHash(),\n          origin: location.origin\n        });\n\n        _this2.connection.destroy();\n        /**\n         * Only clear storage if the session id we have in memory matches the one on disk\n         * Otherwise, in the case where we have 2 tabs, another tab might have cleared\n         * storage already.  In that case if we clear storage again, the user will be in\n         * a state where the first tab allows the user to connect but the session that\n         * was used isn't persisted.  This leaves the user in a state where they aren't\n         * connected to the mobile app.\n         */\n\n\n        var storedSession = Session_1.Session.load(_this2.storage);\n\n        if ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) === _this2._session.id) {\n          _this2.storage.clear();\n        } else if (storedSession) {\n          (_c = _this2.eventListener) === null || _c === void 0 ? void 0 : _c.onEvent(EventListener_1.EVENTS.SKIPPED_CLEARING_SESSION, {\n            sessionIdHash: _this2.getSessionIdHash(),\n            storedSessionIdHash: Session_1.Session.hash(storedSession.id),\n            origin: location.origin\n          });\n        }\n\n        _this2.ui.reloadUI();\n      }, function (err) {\n        var _a;\n\n        (_a = _this2.eventListener) === null || _a === void 0 ? void 0 : _a.onEvent(EventListener_1.EVENTS.FAILURE, {\n          method: \"relay::resetAndReload\",\n          message: \"failed to reset and reload with \".concat(err),\n          sessionIdHash: _this2.getSessionIdHash()\n        });\n      });\n    }\n  }, {\n    key: \"setAppInfo\",\n    value: function setAppInfo(appName, appLogoUrl) {\n      this.appName = appName;\n      this.appLogoUrl = appLogoUrl;\n    }\n  }, {\n    key: \"getStorageItem\",\n    value: function getStorageItem(key) {\n      return this.storage.getItem(key);\n    }\n  }, {\n    key: \"setStorageItem\",\n    value: function setStorageItem(key, value) {\n      this.storage.setItem(key, value);\n    }\n  }, {\n    key: \"signEthereumMessage\",\n    value: function signEthereumMessage(message, address, addPrefix, typedDataJson) {\n      return this.sendRequest({\n        method: Web3Method_1.Web3Method.signEthereumMessage,\n        params: {\n          message: (0, util_1.hexStringFromBuffer)(message, true),\n          address: address,\n          addPrefix: addPrefix,\n          typedDataJson: typedDataJson || null\n        }\n      });\n    }\n  }, {\n    key: \"ethereumAddressFromSignedMessage\",\n    value: function ethereumAddressFromSignedMessage(message, signature, addPrefix) {\n      return this.sendRequest({\n        method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,\n        params: {\n          message: (0, util_1.hexStringFromBuffer)(message, true),\n          signature: (0, util_1.hexStringFromBuffer)(signature, true),\n          addPrefix: addPrefix\n        }\n      });\n    }\n  }, {\n    key: \"signEthereumTransaction\",\n    value: function signEthereumTransaction(params) {\n      return this.sendRequest({\n        method: Web3Method_1.Web3Method.signEthereumTransaction,\n        params: {\n          fromAddress: params.fromAddress,\n          toAddress: params.toAddress,\n          weiValue: (0, util_1.bigIntStringFromBN)(params.weiValue),\n          data: (0, util_1.hexStringFromBuffer)(params.data, true),\n          nonce: params.nonce,\n          gasPriceInWei: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,\n          maxFeePerGas: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,\n          maxPriorityFeePerGas: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,\n          gasLimit: params.gasLimit ? (0, util_1.bigIntStringFromBN)(params.gasLimit) : null,\n          chainId: params.chainId,\n          shouldSubmit: false\n        }\n      });\n    }\n  }, {\n    key: \"signAndSubmitEthereumTransaction\",\n    value: function signAndSubmitEthereumTransaction(params) {\n      return this.sendRequest({\n        method: Web3Method_1.Web3Method.signEthereumTransaction,\n        params: {\n          fromAddress: params.fromAddress,\n          toAddress: params.toAddress,\n          weiValue: (0, util_1.bigIntStringFromBN)(params.weiValue),\n          data: (0, util_1.hexStringFromBuffer)(params.data, true),\n          nonce: params.nonce,\n          gasPriceInWei: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,\n          maxFeePerGas: params.maxFeePerGas ? (0, util_1.bigIntStringFromBN)(params.maxFeePerGas) : null,\n          maxPriorityFeePerGas: params.maxPriorityFeePerGas ? (0, util_1.bigIntStringFromBN)(params.maxPriorityFeePerGas) : null,\n          gasLimit: params.gasLimit ? (0, util_1.bigIntStringFromBN)(params.gasLimit) : null,\n          chainId: params.chainId,\n          shouldSubmit: true\n        }\n      });\n    }\n  }, {\n    key: \"submitEthereumTransaction\",\n    value: function submitEthereumTransaction(signedTransaction, chainId) {\n      return this.sendRequest({\n        method: Web3Method_1.Web3Method.submitEthereumTransaction,\n        params: {\n          signedTransaction: (0, util_1.hexStringFromBuffer)(signedTransaction, true),\n          chainId: chainId\n        }\n      });\n    }\n  }, {\n    key: \"scanQRCode\",\n    value: function scanQRCode(regExp) {\n      return this.sendRequest({\n        method: Web3Method_1.Web3Method.scanQRCode,\n        params: {\n          regExp: regExp\n        }\n      });\n    }\n  }, {\n    key: \"getQRCodeUrl\",\n    value: function getQRCodeUrl() {\n      return (0, util_1.createQrUrl)(this._session.id, this._session.secret, this.linkAPIUrl, false);\n    }\n  }, {\n    key: \"genericRequest\",\n    value: function genericRequest(data, action) {\n      return this.sendRequest({\n        method: Web3Method_1.Web3Method.generic,\n        params: {\n          action: action,\n          data: data\n        }\n      });\n    }\n  }, {\n    key: \"sendGenericMessage\",\n    value: function sendGenericMessage(request) {\n      return this.sendRequest(request);\n    }\n  }, {\n    key: \"sendRequest\",\n    value: function sendRequest(request) {\n      var _this3 = this;\n\n      var hideSnackbarItem = null;\n      var id = (0, util_1.randomBytesHex)(8);\n\n      var cancel = function cancel() {\n        _this3.publishWeb3RequestCanceledEvent(id);\n\n        _this3.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n          id: id,\n          response: (0, Web3Response_1.ErrorResponse)(request.method, \"User rejected request\")\n        }));\n\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n      };\n\n      var promise = new Promise(function (resolve, reject) {\n        if (!_this3.ui.isStandalone()) {\n          hideSnackbarItem = _this3.ui.showConnecting({\n            isUnlinkedErrorState: _this3.isUnlinkedErrorState,\n            onCancel: cancel,\n            onResetConnection: _this3.resetAndReload // eslint-disable-line @typescript-eslint/unbound-method\n\n          });\n        }\n\n        _this3.relayEventManager.callbacks.set(id, function (response) {\n          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n\n          if (response.errorMessage) {\n            return reject(new Error(response.errorMessage));\n          }\n\n          resolve(response);\n        });\n\n        if (_this3.ui.isStandalone()) {\n          _this3.sendRequestStandalone(id, request);\n        } else {\n          _this3.publishWeb3RequestEvent(id, request);\n        }\n      });\n      return {\n        promise: promise,\n        cancel: cancel\n      };\n    }\n  }, {\n    key: \"setConnectDisabled\",\n    value: function setConnectDisabled(disabled) {\n      this.ui.setConnectDisabled(disabled);\n    }\n  }, {\n    key: \"setAccountsCallback\",\n    value: function setAccountsCallback(accountsCallback) {\n      this.accountsCallback = accountsCallback;\n    }\n  }, {\n    key: \"setChainCallback\",\n    value: function setChainCallback(chainCallback) {\n      this.chainCallback = chainCallback;\n    }\n  }, {\n    key: \"publishWeb3RequestEvent\",\n    value: function publishWeb3RequestEvent(id, request) {\n      var _this4 = this;\n\n      var _a;\n\n      var message = (0, Web3RequestMessage_1.Web3RequestMessage)({\n        id: id,\n        request: request\n      });\n      var storedSession = Session_1.Session.load(this.storage);\n      (_a = this.eventListener) === null || _a === void 0 ? void 0 : _a.onEvent(EventListener_1.EVENTS.WEB3_REQUEST, {\n        eventId: message.id,\n        method: \"relay::\".concat(message.request.method),\n        sessionIdHash: this.getSessionIdHash(),\n        storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : \"\",\n        isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString(),\n        origin: location.origin\n      });\n      this.subscriptions.add(this.publishEvent(\"Web3Request\", message, true).subscribe({\n        next: function next(_) {\n          var _a;\n\n          (_a = _this4.eventListener) === null || _a === void 0 ? void 0 : _a.onEvent(EventListener_1.EVENTS.WEB3_REQUEST_PUBLISHED, {\n            eventId: message.id,\n            method: \"relay::\".concat(message.request.method),\n            sessionIdHash: _this4.getSessionIdHash(),\n            storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : \"\",\n            isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== _this4._session.id).toString(),\n            origin: location.origin\n          });\n        },\n        error: function error(err) {\n          _this4.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n            id: message.id,\n            response: {\n              method: message.request.method,\n              errorMessage: err.message\n            }\n          }));\n        }\n      }));\n    }\n  }, {\n    key: \"publishWeb3RequestCanceledEvent\",\n    value: function publishWeb3RequestCanceledEvent(id) {\n      var message = (0, Web3RequestCanceledMessage_1.Web3RequestCanceledMessage)(id);\n      this.subscriptions.add(this.publishEvent(\"Web3RequestCanceled\", message, false).subscribe());\n    }\n  }, {\n    key: \"publishEvent\",\n    value: function publishEvent(event, message, callWebhook) {\n      var _this5 = this;\n\n      var secret = this.session.secret;\n      return new rxjs_1.Observable(function (subscriber) {\n        void aes256gcm.encrypt(JSON.stringify(Object.assign(Object.assign({}, message), {\n          origin: location.origin\n        })), secret).then(function (encrypted) {\n          subscriber.next(encrypted);\n          subscriber.complete();\n        });\n      }).pipe((0, operators_1.mergeMap)(function (encrypted) {\n        return _this5.connection.publishEvent(event, encrypted, callWebhook);\n      }));\n    }\n  }, {\n    key: \"handleIncomingEvent\",\n    value: function handleIncomingEvent(event) {\n      var _this6 = this;\n\n      try {\n        this.subscriptions.add(aes256gcm.decrypt(event.data, this.session.secret).pipe((0, operators_1.map)(function (c) {\n          return JSON.parse(c);\n        })).subscribe({\n          next: function next(json) {\n            var message = (0, Web3ResponseMessage_1.isWeb3ResponseMessage)(json) ? json : null;\n\n            if (!message) {\n              return;\n            }\n\n            _this6.handleWeb3ResponseMessage(message);\n          },\n          error: function error() {\n            var _a;\n\n            (_a = _this6.eventListener) === null || _a === void 0 ? void 0 : _a.onEvent(EventListener_1.EVENTS.GENERAL_ERROR, {\n              message: \"Had error decrypting\",\n              value: \"incomingEvent\"\n            });\n          }\n        }));\n      } catch (_a) {\n        return;\n      }\n    }\n  }, {\n    key: \"handleWeb3ResponseMessage\",\n    value: function handleWeb3ResponseMessage(message) {\n      var _this7 = this;\n\n      var _a;\n\n      var response = message.response;\n      (_a = this.eventListener) === null || _a === void 0 ? void 0 : _a.onEvent(EventListener_1.EVENTS.WEB3_RESPONSE, {\n        eventId: message.id,\n        method: \"relay::\".concat(response.method),\n        sessionIdHash: this.getSessionIdHash(),\n        origin: location.origin\n      });\n\n      if ((0, Web3Response_1.isRequestEthereumAccountsResponse)(response)) {\n        WalletSDKRelay.accountRequestCallbackIds.forEach(function (id) {\n          return _this7.invokeCallback(Object.assign(Object.assign({}, message), {\n            id: id\n          }));\n        });\n        WalletSDKRelay.accountRequestCallbackIds.clear();\n        return;\n      }\n\n      this.invokeCallback(message);\n    }\n  }, {\n    key: \"invokeCallback\",\n    value: function invokeCallback(message) {\n      var callback = this.relayEventManager.callbacks.get(message.id);\n\n      if (callback) {\n        callback(message.response);\n        this.relayEventManager.callbacks.delete(message.id);\n      }\n    }\n  }, {\n    key: \"requestEthereumAccounts\",\n    value: function requestEthereumAccounts() {\n      var _this8 = this;\n\n      var request = {\n        method: Web3Method_1.Web3Method.requestEthereumAccounts,\n        params: {\n          appName: this.appName,\n          appLogoUrl: this.appLogoUrl || null\n        }\n      };\n      var hideSnackbarItem = null;\n      var id = (0, util_1.randomBytesHex)(8);\n\n      var cancel = function cancel() {\n        _this8.publishWeb3RequestCanceledEvent(id);\n\n        _this8.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n          id: id,\n          response: (0, Web3Response_1.ErrorResponse)(request.method, \"User rejected request\")\n        })); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n\n\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n      };\n\n      var promise = new Promise(function (resolve, reject) {\n        var _a;\n\n        _this8.relayEventManager.callbacks.set(id, function (response) {\n          _this8.ui.hideRequestEthereumAccounts(); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n\n\n          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n\n          if (response.errorMessage) {\n            return reject(new Error(response.errorMessage));\n          }\n\n          resolve(response);\n        });\n\n        var userAgent = ((_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) || null;\n\n        if (userAgent && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {\n          window.location.href = \"https://go.cb-w.com/xoXnYwQimhb?cb_url=\".concat(encodeURIComponent(window.location.href));\n          return;\n        }\n\n        if (_this8.ui.inlineAccountsResponse()) {\n          var onAccounts = function onAccounts(accounts) {\n            _this8.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n              id: id,\n              response: (0, Web3Response_1.RequestEthereumAccountsResponse)(accounts)\n            }));\n          };\n\n          _this8.ui.requestEthereumAccounts({\n            onCancel: cancel,\n            onAccounts: onAccounts\n          });\n        } else {\n          _this8.ui.requestEthereumAccounts({\n            onCancel: cancel\n          });\n        }\n\n        WalletSDKRelay.accountRequestCallbackIds.add(id);\n\n        if (!_this8.ui.inlineAccountsResponse() && !_this8.ui.isStandalone()) {\n          _this8.publishWeb3RequestEvent(id, request);\n        }\n      });\n      return {\n        promise: promise,\n        cancel: cancel\n      };\n    }\n  }, {\n    key: \"watchAsset\",\n    value: function watchAsset(type, address, symbol, decimals, image, chainId) {\n      var _this9 = this;\n\n      var request = {\n        method: Web3Method_1.Web3Method.watchAsset,\n        params: {\n          type: type,\n          options: {\n            address: address,\n            symbol: symbol,\n            decimals: decimals,\n            image: image\n          },\n          chainId: chainId\n        }\n      };\n      var hideSnackbarItem = null;\n      var id = (0, util_1.randomBytesHex)(8);\n\n      var cancel = function cancel() {\n        _this9.publishWeb3RequestCanceledEvent(id);\n\n        _this9.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n          id: id,\n          response: (0, Web3Response_1.ErrorResponse)(request.method, \"User rejected request\")\n        }));\n\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n      };\n\n      if (!this.ui.inlineWatchAsset()) {\n        hideSnackbarItem = this.ui.showConnecting({\n          isUnlinkedErrorState: this.isUnlinkedErrorState,\n          onCancel: cancel,\n          onResetConnection: this.resetAndReload // eslint-disable-line @typescript-eslint/unbound-method\n\n        });\n      }\n\n      var promise = new Promise(function (resolve, reject) {\n        _this9.relayEventManager.callbacks.set(id, function (response) {\n          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n\n          if (response.errorMessage) {\n            return reject(new Error(response.errorMessage));\n          }\n\n          resolve(response);\n        });\n\n        var _cancel = function _cancel() {\n          _this9.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n            id: id,\n            response: (0, Web3Response_1.WatchAssetReponse)(false)\n          }));\n        };\n\n        var approve = function approve() {\n          _this9.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n            id: id,\n            response: (0, Web3Response_1.WatchAssetReponse)(true)\n          }));\n        };\n\n        if (_this9.ui.inlineWatchAsset()) {\n          _this9.ui.watchAsset({\n            onApprove: approve,\n            onCancel: _cancel,\n            type: type,\n            address: address,\n            symbol: symbol,\n            decimals: decimals,\n            image: image,\n            chainId: chainId\n          });\n        }\n\n        if (!_this9.ui.inlineWatchAsset() && !_this9.ui.isStandalone()) {\n          _this9.publishWeb3RequestEvent(id, request);\n        }\n      });\n      return {\n        cancel: cancel,\n        promise: promise\n      };\n    }\n  }, {\n    key: \"addEthereumChain\",\n    value: function addEthereumChain(chainId, rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency) {\n      var _this10 = this;\n\n      var request = {\n        method: Web3Method_1.Web3Method.addEthereumChain,\n        params: {\n          chainId: chainId,\n          rpcUrls: rpcUrls,\n          blockExplorerUrls: blockExplorerUrls,\n          chainName: chainName,\n          iconUrls: iconUrls,\n          nativeCurrency: nativeCurrency\n        }\n      };\n      var hideSnackbarItem = null;\n      var id = (0, util_1.randomBytesHex)(8);\n\n      var cancel = function cancel() {\n        _this10.publishWeb3RequestCanceledEvent(id);\n\n        _this10.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n          id: id,\n          response: (0, Web3Response_1.ErrorResponse)(request.method, \"User rejected request\")\n        }));\n\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n      };\n\n      if (!this.ui.inlineAddEthereumChain(chainId)) {\n        hideSnackbarItem = this.ui.showConnecting({\n          isUnlinkedErrorState: this.isUnlinkedErrorState,\n          onCancel: cancel,\n          onResetConnection: this.resetAndReload // eslint-disable-line @typescript-eslint/unbound-method\n\n        });\n      }\n\n      var promise = new Promise(function (resolve, reject) {\n        _this10.relayEventManager.callbacks.set(id, function (response) {\n          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n\n          if (response.errorMessage) {\n            return reject(new Error(response.errorMessage));\n          }\n\n          resolve(response);\n        });\n\n        var _cancel = function _cancel() {\n          _this10.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n            id: id,\n            response: (0, Web3Response_1.AddEthereumChainResponse)({\n              isApproved: false,\n              rpcUrl: \"\"\n            })\n          }));\n        };\n\n        var approve = function approve(rpcUrl) {\n          _this10.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n            id: id,\n            response: (0, Web3Response_1.AddEthereumChainResponse)({\n              isApproved: true,\n              rpcUrl: rpcUrl\n            })\n          }));\n        };\n\n        if (_this10.ui.inlineAddEthereumChain(chainId)) {\n          _this10.ui.addEthereumChain({\n            onCancel: _cancel,\n            onApprove: approve,\n            chainId: request.params.chainId,\n            rpcUrls: request.params.rpcUrls,\n            blockExplorerUrls: request.params.blockExplorerUrls,\n            chainName: request.params.chainName,\n            iconUrls: request.params.iconUrls,\n            nativeCurrency: request.params.nativeCurrency\n          });\n        }\n\n        if (!_this10.ui.inlineAddEthereumChain(chainId) && !_this10.ui.isStandalone()) {\n          _this10.publishWeb3RequestEvent(id, request);\n        }\n      });\n      return {\n        promise: promise,\n        cancel: cancel\n      };\n    }\n  }, {\n    key: \"switchEthereumChain\",\n    value: function switchEthereumChain(chainId) {\n      var _this11 = this;\n\n      var request = {\n        method: Web3Method_1.Web3Method.switchEthereumChain,\n        params: {\n          chainId: chainId\n        }\n      };\n      var hideSnackbarItem = null;\n      var id = (0, util_1.randomBytesHex)(8);\n\n      var cancel = function cancel() {\n        _this11.publishWeb3RequestCanceledEvent(id);\n\n        _this11.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n          id: id,\n          response: (0, Web3Response_1.ErrorResponse)(request.method, \"User rejected request\")\n        }));\n\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n      };\n\n      if (!this.ui.inlineSwitchEthereumChain()) {\n        hideSnackbarItem = this.ui.showConnecting({\n          isUnlinkedErrorState: this.isUnlinkedErrorState,\n          onCancel: cancel,\n          onResetConnection: this.resetAndReload // eslint-disable-line @typescript-eslint/unbound-method\n\n        });\n      }\n\n      var promise = new Promise(function (resolve, reject) {\n        _this11.relayEventManager.callbacks.set(id, function (response) {\n          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n\n          if (response.errorMessage && response.errorCode) {\n            return reject(eth_rpc_errors_1.ethErrors.provider.custom({\n              code: response.errorCode,\n              message: \"Unrecognized chain ID. Try adding the chain using addEthereumChain first.\"\n            }));\n          } else if (response.errorMessage) {\n            return reject(new Error(response.errorMessage));\n          }\n\n          resolve(response);\n        });\n\n        var _cancel = function _cancel(errorCode) {\n          if (errorCode) {\n            _this11.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n              id: id,\n              response: (0, Web3Response_1.ErrorResponse)(Web3Method_1.Web3Method.switchEthereumChain, \"unsupported chainId\", errorCode)\n            }));\n          } else {\n            _this11.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n              id: id,\n              response: (0, Web3Response_1.SwitchEthereumChainResponse)({\n                isApproved: false,\n                rpcUrl: \"\"\n              })\n            }));\n          }\n        };\n\n        var approve = function approve(rpcUrl) {\n          _this11.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n            id: id,\n            response: (0, Web3Response_1.SwitchEthereumChainResponse)({\n              isApproved: true,\n              rpcUrl: rpcUrl\n            })\n          }));\n        };\n\n        _this11.ui.switchEthereumChain({\n          onCancel: _cancel,\n          onApprove: approve,\n          chainId: request.params.chainId\n        });\n\n        if (!_this11.ui.inlineSwitchEthereumChain() && !_this11.ui.isStandalone()) {\n          _this11.publishWeb3RequestEvent(id, request);\n        }\n      });\n      return {\n        promise: promise,\n        cancel: cancel\n      };\n    }\n  }, {\n    key: \"inlineAddEthereumChain\",\n    value: function inlineAddEthereumChain(chainId) {\n      return this.ui.inlineAddEthereumChain(chainId);\n    }\n  }, {\n    key: \"getSessionIdHash\",\n    value: function getSessionIdHash() {\n      return Session_1.Session.hash(this._session.id);\n    }\n  }, {\n    key: \"sendRequestStandalone\",\n    value: function sendRequestStandalone(id, request) {\n      var _this12 = this;\n\n      var _cancel = function _cancel() {\n        _this12.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n          id: id,\n          response: (0, Web3Response_1.ErrorResponse)(request.method, \"User rejected request\")\n        }));\n      };\n\n      var onSuccess = function onSuccess(response) {\n        _this12.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n          id: id,\n          response: response\n        }));\n      };\n\n      switch (request.method) {\n        case Web3Method_1.Web3Method.signEthereumMessage:\n          this.ui.signEthereumMessage({\n            request: request,\n            onSuccess: onSuccess,\n            onCancel: _cancel\n          });\n          break;\n\n        case Web3Method_1.Web3Method.signEthereumTransaction:\n          this.ui.signEthereumTransaction({\n            request: request,\n            onSuccess: onSuccess,\n            onCancel: _cancel\n          });\n          break;\n\n        case Web3Method_1.Web3Method.submitEthereumTransaction:\n          this.ui.submitEthereumTransaction({\n            request: request,\n            onSuccess: onSuccess,\n            onCancel: _cancel\n          });\n          break;\n\n        case Web3Method_1.Web3Method.ethereumAddressFromSignedMessage:\n          this.ui.ethereumAddressFromSignedMessage({\n            request: request,\n            onSuccess: onSuccess\n          });\n          break;\n\n        default:\n          _cancel();\n\n          break;\n      }\n    }\n  }, {\n    key: \"session\",\n    get: function get() {\n      return this._session;\n    }\n  }]);\n\n  return WalletSDKRelay;\n}(WalletSDKRelayAbstract_1.WalletSDKRelayAbstract);\n\nWalletSDKRelay.accountRequestCallbackIds = new Set();\n\n__decorate([bind_decorator_1.default], WalletSDKRelay.prototype, \"resetAndReload\", null);\n\n__decorate([bind_decorator_1.default], WalletSDKRelay.prototype, \"handleIncomingEvent\", null);\n\nexports.WalletSDKRelay = WalletSDKRelay;","map":null,"metadata":{},"sourceType":"script"}